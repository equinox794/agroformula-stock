"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/i18next";
exports.ids = ["vendor-chunks/i18next"];
exports.modules = {

/***/ "(ssr)/./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   keyFromSelector: () => (/* binding */ keysFromSelector),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nconst isString = (obj)=>typeof obj === \"string\";\nconst defer = ()=>{\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n};\nconst makeString = (object)=>{\n    if (object == null) return \"\";\n    return \"\" + object;\n};\nconst copy = (a, s, t)=>{\n    a.forEach((m)=>{\n        if (s[m]) t[m] = s[m];\n    });\n};\nconst lastOfPathSeparatorRegExp = /###/g;\nconst cleanKey = (key)=>key && key.indexOf(\"###\") > -1 ? key.replace(lastOfPathSeparatorRegExp, \".\") : key;\nconst canNotTraverseDeeper = (object)=>!object || isString(object);\nconst getLastOfPath = (object, path, Empty)=>{\n    const stack = !isString(path) ? path : path.split(\".\");\n    let stackIndex = 0;\n    while(stackIndex < stack.length - 1){\n        if (canNotTraverseDeeper(object)) return {};\n        const key = cleanKey(stack[stackIndex]);\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n        ++stackIndex;\n    }\n    if (canNotTraverseDeeper(object)) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack[stackIndex])\n    };\n};\nconst setPath = (object, path, newValue)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    if (obj !== undefined || path.length === 1) {\n        obj[k] = newValue;\n        return;\n    }\n    let e = path[path.length - 1];\n    let p = path.slice(0, path.length - 1);\n    let last = getLastOfPath(object, p, Object);\n    while(last.obj === undefined && p.length){\n        e = `${p[p.length - 1]}.${e}`;\n        p = p.slice(0, p.length - 1);\n        last = getLastOfPath(object, p, Object);\n        if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== \"undefined\") {\n            last.obj = undefined;\n        }\n    }\n    last.obj[`${last.k}.${e}`] = newValue;\n};\nconst pushPath = (object, path, newValue, concat)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = obj[k] || [];\n    obj[k].push(newValue);\n};\nconst getPath = (object, path)=>{\n    const { obj, k } = getLastOfPath(object, path);\n    if (!obj) return undefined;\n    if (!Object.prototype.hasOwnProperty.call(obj, k)) return undefined;\n    return obj[k];\n};\nconst getPathWithDefaults = (data, defaultData, key)=>{\n    const value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n};\nconst deepExtend = (target, source, overwrite)=>{\n    for(const prop in source){\n        if (prop !== \"__proto__\" && prop !== \"constructor\") {\n            if (prop in target) {\n                if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n};\nconst regexEscape = (str)=>str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\nvar _entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\"\n};\nconst escape = (data)=>{\n    if (isString(data)) {\n        return data.replace(/[&<>\"'\\/]/g, (s)=>_entityMap[s]);\n    }\n    return data;\n};\nclass RegExpCache {\n    constructor(capacity){\n        this.capacity = capacity;\n        this.regExpMap = new Map();\n        this.regExpQueue = [];\n    }\n    getRegExp(pattern) {\n        const regExpFromCache = this.regExpMap.get(pattern);\n        if (regExpFromCache !== undefined) {\n            return regExpFromCache;\n        }\n        const regExpNew = new RegExp(pattern);\n        if (this.regExpQueue.length === this.capacity) {\n            this.regExpMap.delete(this.regExpQueue.shift());\n        }\n        this.regExpMap.set(pattern, regExpNew);\n        this.regExpQueue.push(pattern);\n        return regExpNew;\n    }\n}\nconst chars = [\n    \" \",\n    \",\",\n    \"?\",\n    \"!\",\n    \";\"\n];\nconst looksLikeObjectPathRegExpCache = new RegExpCache(20);\nconst looksLikeObjectPath = (key, nsSeparator, keySeparator)=>{\n    nsSeparator = nsSeparator || \"\";\n    keySeparator = keySeparator || \"\";\n    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n    if (possibleChars.length === 0) return true;\n    const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c)=>c === \"?\" ? \"\\\\?\" : c).join(\"|\")})`);\n    let matched = !r.test(key);\n    if (!matched) {\n        const ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n};\nconst deepFind = (obj, path, keySeparator = \".\")=>{\n    if (!obj) return undefined;\n    if (obj[path]) {\n        if (!Object.prototype.hasOwnProperty.call(obj, path)) return undefined;\n        return obj[path];\n    }\n    const tokens = path.split(keySeparator);\n    let current = obj;\n    for(let i = 0; i < tokens.length;){\n        if (!current || typeof current !== \"object\") {\n            return undefined;\n        }\n        let next;\n        let nextPath = \"\";\n        for(let j = i; j < tokens.length; ++j){\n            if (j !== i) {\n                nextPath += keySeparator;\n            }\n            nextPath += tokens[j];\n            next = current[nextPath];\n            if (next !== undefined) {\n                if ([\n                    \"string\",\n                    \"number\",\n                    \"boolean\"\n                ].indexOf(typeof next) > -1 && j < tokens.length - 1) {\n                    continue;\n                }\n                i += j - i + 1;\n                break;\n            }\n        }\n        current = next;\n    }\n    return current;\n};\nconst getCleanedCode = (code)=>code?.replace(\"_\", \"-\");\nconst consoleLogger = {\n    type: \"logger\",\n    log (args) {\n        this.output(\"log\", args);\n    },\n    warn (args) {\n        this.output(\"warn\", args);\n    },\n    error (args) {\n        this.output(\"error\", args);\n    },\n    output (type, args) {\n        console?.[type]?.apply?.(console, args);\n    }\n};\nclass Logger {\n    constructor(concreteLogger, options = {}){\n        this.init(concreteLogger, options);\n    }\n    init(concreteLogger, options = {}) {\n        this.prefix = options.prefix || \"i18next:\";\n        this.logger = concreteLogger || consoleLogger;\n        this.options = options;\n        this.debug = options.debug;\n    }\n    log(...args) {\n        return this.forward(args, \"log\", \"\", true);\n    }\n    warn(...args) {\n        return this.forward(args, \"warn\", \"\", true);\n    }\n    error(...args) {\n        return this.forward(args, \"error\", \"\");\n    }\n    deprecate(...args) {\n        return this.forward(args, \"warn\", \"WARNING DEPRECATED: \", true);\n    }\n    forward(args, lvl, prefix, debugOnly) {\n        if (debugOnly && !this.debug) return null;\n        if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;\n        return this.logger[lvl](args);\n    }\n    create(moduleName) {\n        return new Logger(this.logger, {\n            ...{\n                prefix: `${this.prefix}:${moduleName}:`\n            },\n            ...this.options\n        });\n    }\n    clone(options) {\n        options = options || this.options;\n        options.prefix = options.prefix || this.prefix;\n        return new Logger(this.logger, options);\n    }\n}\nvar baseLogger = new Logger();\nclass EventEmitter {\n    constructor(){\n        this.observers = {};\n    }\n    on(events, listener) {\n        events.split(\" \").forEach((event)=>{\n            if (!this.observers[event]) this.observers[event] = new Map();\n            const numListeners = this.observers[event].get(listener) || 0;\n            this.observers[event].set(listener, numListeners + 1);\n        });\n        return this;\n    }\n    off(event, listener) {\n        if (!this.observers[event]) return;\n        if (!listener) {\n            delete this.observers[event];\n            return;\n        }\n        this.observers[event].delete(listener);\n    }\n    emit(event, ...args) {\n        if (this.observers[event]) {\n            const cloned = Array.from(this.observers[event].entries());\n            cloned.forEach(([observer, numTimesAdded])=>{\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer(...args);\n                }\n            });\n        }\n        if (this.observers[\"*\"]) {\n            const cloned = Array.from(this.observers[\"*\"].entries());\n            cloned.forEach(([observer, numTimesAdded])=>{\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer.apply(observer, [\n                        event,\n                        ...args\n                    ]);\n                }\n            });\n        }\n    }\n}\nclass ResourceStore extends EventEmitter {\n    constructor(data, options = {\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: \"translation\"\n    }){\n        super();\n        this.data = data || {};\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        if (this.options.ignoreJSONStructure === undefined) {\n            this.options.ignoreJSONStructure = true;\n        }\n    }\n    addNamespaces(ns) {\n        if (this.options.ns.indexOf(ns) < 0) {\n            this.options.ns.push(ns);\n        }\n    }\n    removeNamespaces(ns) {\n        const index = this.options.ns.indexOf(ns);\n        if (index > -1) {\n            this.options.ns.splice(index, 1);\n        }\n    }\n    getResource(lng, ns, key, options = {}) {\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n        let path;\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n        } else {\n            path = [\n                lng,\n                ns\n            ];\n            if (key) {\n                if (Array.isArray(key)) {\n                    path.push(...key);\n                } else if (isString(key) && keySeparator) {\n                    path.push(...key.split(keySeparator));\n                } else {\n                    path.push(key);\n                }\n            }\n        }\n        const result = getPath(this.data, path);\n        if (!result && !ns && !key && lng.indexOf(\".\") > -1) {\n            lng = path[0];\n            ns = path[1];\n            key = path.slice(2).join(\".\");\n        }\n        if (result || !ignoreJSONStructure || !isString(key)) return result;\n        return deepFind(this.data?.[lng]?.[ns], key, keySeparator);\n    }\n    addResource(lng, ns, key, value, options = {\n        silent: false\n    }) {\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            value = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        setPath(this.data, path, value);\n        if (!options.silent) this.emit(\"added\", lng, ns, key, value);\n    }\n    addResources(lng, ns, resources, options = {\n        silent: false\n    }) {\n        for(const m in resources){\n            if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {\n                silent: true\n            });\n        }\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    addResourceBundle(lng, ns, resources, deep, overwrite, options = {\n        silent: false,\n        skipCopy: false\n    }) {\n        let path = [\n            lng,\n            ns\n        ];\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            deep = resources;\n            resources = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        let pack = getPath(this.data, path) || {};\n        if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n        if (deep) {\n            deepExtend(pack, resources, overwrite);\n        } else {\n            pack = {\n                ...pack,\n                ...resources\n            };\n        }\n        setPath(this.data, path, pack);\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    removeResourceBundle(lng, ns) {\n        if (this.hasResourceBundle(lng, ns)) {\n            delete this.data[lng][ns];\n        }\n        this.removeNamespaces(ns);\n        this.emit(\"removed\", lng, ns);\n    }\n    hasResourceBundle(lng, ns) {\n        return this.getResource(lng, ns) !== undefined;\n    }\n    getResourceBundle(lng, ns) {\n        if (!ns) ns = this.options.defaultNS;\n        return this.getResource(lng, ns);\n    }\n    getDataByLanguage(lng) {\n        return this.data[lng];\n    }\n    hasLanguageSomeTranslations(lng) {\n        const data = this.getDataByLanguage(lng);\n        const n = data && Object.keys(data) || [];\n        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);\n    }\n    toJSON() {\n        return this.data;\n    }\n}\nvar postProcessor = {\n    processors: {},\n    addPostProcessor (module) {\n        this.processors[module.name] = module;\n    },\n    handle (processors, value, key, options, translator) {\n        processors.forEach((processor)=>{\n            value = this.processors[processor]?.process(value, key, options, translator) ?? value;\n        });\n        return value;\n    }\n};\nconst PATH_KEY = Symbol(\"i18next/PATH_KEY\");\nfunction createProxy() {\n    const state = [];\n    const handler = Object.create(null);\n    let proxy;\n    handler.get = (target, key)=>{\n        proxy?.revoke?.();\n        if (key === PATH_KEY) return state;\n        state.push(key);\n        proxy = Proxy.revocable(target, handler);\n        return proxy.proxy;\n    };\n    return Proxy.revocable(Object.create(null), handler).proxy;\n}\nfunction keysFromSelector(selector, opts) {\n    const { [PATH_KEY]: path } = selector(createProxy());\n    return path.join(opts?.keySeparator ?? \".\");\n}\nconst checkedLoadedFor = {};\nconst shouldHandleAsObject = (res)=>!isString(res) && typeof res !== \"boolean\" && typeof res !== \"number\";\nclass Translator extends EventEmitter {\n    constructor(services, options = {}){\n        super();\n        copy([\n            \"resourceStore\",\n            \"languageUtils\",\n            \"pluralResolver\",\n            \"interpolator\",\n            \"backendConnector\",\n            \"i18nFormat\",\n            \"utils\"\n        ], services, this);\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        this.logger = baseLogger.create(\"translator\");\n    }\n    changeLanguage(lng) {\n        if (lng) this.language = lng;\n    }\n    exists(key, o = {\n        interpolation: {}\n    }) {\n        const opt = {\n            ...o\n        };\n        if (key == null) return false;\n        const resolved = this.resolve(key, opt);\n        if (resolved?.res === undefined) return false;\n        const isObject = shouldHandleAsObject(resolved.res);\n        if (opt.returnObjects === false && isObject) {\n            return false;\n        }\n        return true;\n    }\n    extractFromKey(key, opt) {\n        let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n        let namespaces = opt.ns || this.options.defaultNS || [];\n        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n            const m = key.match(this.interpolator.nestingRegexp);\n            if (m && m.length > 0) {\n                return {\n                    key,\n                    namespaces: isString(namespaces) ? [\n                        namespaces\n                    ] : namespaces\n                };\n            }\n            const parts = key.split(nsSeparator);\n            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n            key = parts.join(keySeparator);\n        }\n        return {\n            key,\n            namespaces: isString(namespaces) ? [\n                namespaces\n            ] : namespaces\n        };\n    }\n    translate(keys, o, lastKey) {\n        let opt = typeof o === \"object\" ? {\n            ...o\n        } : o;\n        if (typeof opt !== \"object\" && this.options.overloadTranslationOptionHandler) {\n            opt = this.options.overloadTranslationOptionHandler(arguments);\n        }\n        if (typeof opt === \"object\") opt = {\n            ...opt\n        };\n        if (!opt) opt = {};\n        if (keys == null) return \"\";\n        if (typeof keys === \"function\") keys = keysFromSelector(keys, {\n            ...this.options,\n            ...opt\n        });\n        if (!Array.isArray(keys)) keys = [\n            String(keys)\n        ];\n        const returnDetails = opt.returnDetails !== undefined ? opt.returnDetails : this.options.returnDetails;\n        const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], opt);\n        const namespace = namespaces[namespaces.length - 1];\n        let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const lng = opt.lng || this.language;\n        const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n        if (lng?.toLowerCase() === \"cimode\") {\n            if (appendNamespaceToCIMode) {\n                if (returnDetails) {\n                    return {\n                        res: `${namespace}${nsSeparator}${key}`,\n                        usedKey: key,\n                        exactUsedKey: key,\n                        usedLng: lng,\n                        usedNS: namespace,\n                        usedParams: this.getUsedParamsDetails(opt)\n                    };\n                }\n                return `${namespace}${nsSeparator}${key}`;\n            }\n            if (returnDetails) {\n                return {\n                    res: key,\n                    usedKey: key,\n                    exactUsedKey: key,\n                    usedLng: lng,\n                    usedNS: namespace,\n                    usedParams: this.getUsedParamsDetails(opt)\n                };\n            }\n            return key;\n        }\n        const resolved = this.resolve(keys, opt);\n        let res = resolved?.res;\n        const resUsedKey = resolved?.usedKey || key;\n        const resExactUsedKey = resolved?.exactUsedKey || key;\n        const noObject = [\n            \"[object Number]\",\n            \"[object Function]\",\n            \"[object RegExp]\"\n        ];\n        const joinArrays = opt.joinArrays !== undefined ? opt.joinArrays : this.options.joinArrays;\n        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n        const needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n        const hasDefaultValue = Translator.hasDefaultValue(opt);\n        const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : \"\";\n        const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {\n            ordinal: false\n        }) : \"\";\n        const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n        const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;\n        let resForObjHndl = res;\n        if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {\n            resForObjHndl = defaultValue;\n        }\n        const handleAsObject = shouldHandleAsObject(resForObjHndl);\n        const resType = Object.prototype.toString.apply(resForObjHndl);\n        if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {\n            if (!opt.returnObjects && !this.options.returnObjects) {\n                if (!this.options.returnedObjectHandler) {\n                    this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\");\n                }\n                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {\n                    ...opt,\n                    ns: namespaces\n                }) : `key '${key} (${this.language})' returned an object instead of string.`;\n                if (returnDetails) {\n                    resolved.res = r;\n                    resolved.usedParams = this.getUsedParamsDetails(opt);\n                    return resolved;\n                }\n                return r;\n            }\n            if (keySeparator) {\n                const resTypeIsArray = Array.isArray(resForObjHndl);\n                const copy = resTypeIsArray ? [] : {};\n                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                for(const m in resForObjHndl){\n                    if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {\n                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n                        if (hasDefaultValue && !res) {\n                            copy[m] = this.translate(deepKey, {\n                                ...opt,\n                                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : undefined,\n                                ...{\n                                    joinArrays: false,\n                                    ns: namespaces\n                                }\n                            });\n                        } else {\n                            copy[m] = this.translate(deepKey, {\n                                ...opt,\n                                ...{\n                                    joinArrays: false,\n                                    ns: namespaces\n                                }\n                            });\n                        }\n                        if (copy[m] === deepKey) copy[m] = resForObjHndl[m];\n                    }\n                }\n                res = copy;\n            }\n        } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {\n            res = res.join(joinArrays);\n            if (res) res = this.extendTranslation(res, keys, opt, lastKey);\n        } else {\n            let usedDefault = false;\n            let usedKey = false;\n            if (!this.isValidLookup(res) && hasDefaultValue) {\n                usedDefault = true;\n                res = defaultValue;\n            }\n            if (!this.isValidLookup(res)) {\n                usedKey = true;\n                res = key;\n            }\n            const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n            if (usedKey || usedDefault || updateMissing) {\n                this.logger.log(updateMissing ? \"updateKey\" : \"missingKey\", lng, namespace, key, updateMissing ? defaultValue : res);\n                if (keySeparator) {\n                    const fk = this.resolve(key, {\n                        ...opt,\n                        keySeparator: false\n                    });\n                    if (fk && fk.res) this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\");\n                }\n                let lngs = [];\n                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);\n                if (this.options.saveMissingTo === \"fallback\" && fallbackLngs && fallbackLngs[0]) {\n                    for(let i = 0; i < fallbackLngs.length; i++){\n                        lngs.push(fallbackLngs[i]);\n                    }\n                } else if (this.options.saveMissingTo === \"all\") {\n                    lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);\n                } else {\n                    lngs.push(opt.lng || this.language);\n                }\n                const send = (l, k, specificDefaultValue)=>{\n                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                    if (this.options.missingKeyHandler) {\n                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);\n                    } else if (this.backendConnector?.saveMissing) {\n                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);\n                    }\n                    this.emit(\"missingKey\", l, namespace, k, res);\n                };\n                if (this.options.saveMissing) {\n                    if (this.options.saveMissingPlurals && needsPluralHandling) {\n                        lngs.forEach((language)=>{\n                            const suffixes = this.pluralResolver.getSuffixes(language, opt);\n                            if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {\n                                suffixes.push(`${this.options.pluralSeparator}zero`);\n                            }\n                            suffixes.forEach((suffix)=>{\n                                send([\n                                    language\n                                ], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);\n                            });\n                        });\n                    } else {\n                        send(lngs, key, defaultValue);\n                    }\n                }\n            }\n            res = this.extendTranslation(res, keys, opt, resolved, lastKey);\n            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {\n                res = `${namespace}${nsSeparator}${key}`;\n            }\n            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : undefined, opt);\n            }\n        }\n        if (returnDetails) {\n            resolved.res = res;\n            resolved.usedParams = this.getUsedParamsDetails(opt);\n            return resolved;\n        }\n        return res;\n    }\n    extendTranslation(res, key, opt, resolved, lastKey) {\n        if (this.i18nFormat?.parse) {\n            res = this.i18nFormat.parse(res, {\n                ...this.options.interpolation.defaultVariables,\n                ...opt\n            }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                resolved\n            });\n        } else if (!opt.skipInterpolation) {\n            if (opt.interpolation) this.interpolator.init({\n                ...opt,\n                ...{\n                    interpolation: {\n                        ...this.options.interpolation,\n                        ...opt.interpolation\n                    }\n                }\n            });\n            const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== undefined ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n            let nestBef;\n            if (skipOnVariables) {\n                const nb = res.match(this.interpolator.nestingRegexp);\n                nestBef = nb && nb.length;\n            }\n            let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;\n            if (this.options.interpolation.defaultVariables) data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n            res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);\n            if (skipOnVariables) {\n                const na = res.match(this.interpolator.nestingRegexp);\n                const nestAft = na && na.length;\n                if (nestBef < nestAft) opt.nest = false;\n            }\n            if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;\n            if (opt.nest !== false) res = this.interpolator.nest(res, (...args)=>{\n                if (lastKey?.[0] === args[0] && !opt.context) {\n                    this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n                    return null;\n                }\n                return this.translate(...args, key);\n            }, opt);\n            if (opt.interpolation) this.interpolator.reset();\n        }\n        const postProcess = opt.postProcess || this.options.postProcess;\n        const postProcessorNames = isString(postProcess) ? [\n            postProcess\n        ] : postProcess;\n        if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {\n            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                i18nResolved: {\n                    ...resolved,\n                    usedParams: this.getUsedParamsDetails(opt)\n                },\n                ...opt\n            } : opt, this);\n        }\n        return res;\n    }\n    resolve(keys, opt = {}) {\n        let found;\n        let usedKey;\n        let exactUsedKey;\n        let usedLng;\n        let usedNS;\n        if (isString(keys)) keys = [\n            keys\n        ];\n        keys.forEach((k)=>{\n            if (this.isValidLookup(found)) return;\n            const extracted = this.extractFromKey(k, opt);\n            const key = extracted.key;\n            usedKey = key;\n            let namespaces = extracted.namespaces;\n            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n            const needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n            const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n            const needsContextHandling = opt.context !== undefined && (isString(opt.context) || typeof opt.context === \"number\") && opt.context !== \"\";\n            const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);\n            namespaces.forEach((ns)=>{\n                if (this.isValidLookup(found)) return;\n                usedNS = ns;\n                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {\n                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n                    this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(\", \")}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n                }\n                codes.forEach((code)=>{\n                    if (this.isValidLookup(found)) return;\n                    usedLng = code;\n                    const finalKeys = [\n                        key\n                    ];\n                    if (this.i18nFormat?.addLookupKeys) {\n                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);\n                    } else {\n                        let pluralSuffix;\n                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);\n                        const zeroSuffix = `${this.options.pluralSeparator}zero`;\n                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n                        if (needsPluralHandling) {\n                            if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                            }\n                            finalKeys.push(key + pluralSuffix);\n                            if (needsZeroSuffixLookup) {\n                                finalKeys.push(key + zeroSuffix);\n                            }\n                        }\n                        if (needsContextHandling) {\n                            const contextKey = `${key}${this.options.contextSeparator || \"_\"}${opt.context}`;\n                            finalKeys.push(contextKey);\n                            if (needsPluralHandling) {\n                                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                                }\n                                finalKeys.push(contextKey + pluralSuffix);\n                                if (needsZeroSuffixLookup) {\n                                    finalKeys.push(contextKey + zeroSuffix);\n                                }\n                            }\n                        }\n                    }\n                    let possibleKey;\n                    while(possibleKey = finalKeys.pop()){\n                        if (!this.isValidLookup(found)) {\n                            exactUsedKey = possibleKey;\n                            found = this.getResource(code, ns, possibleKey, opt);\n                        }\n                    }\n                });\n            });\n        });\n        return {\n            res: found,\n            usedKey,\n            exactUsedKey,\n            usedLng,\n            usedNS\n        };\n    }\n    isValidLookup(res) {\n        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === \"\");\n    }\n    getResource(code, ns, key, options = {}) {\n        if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n        return this.resourceStore.getResource(code, ns, key, options);\n    }\n    getUsedParamsDetails(options = {}) {\n        const optionsKeys = [\n            \"defaultValue\",\n            \"ordinal\",\n            \"context\",\n            \"replace\",\n            \"lng\",\n            \"lngs\",\n            \"fallbackLng\",\n            \"ns\",\n            \"keySeparator\",\n            \"nsSeparator\",\n            \"returnObjects\",\n            \"returnDetails\",\n            \"joinArrays\",\n            \"postProcess\",\n            \"interpolation\"\n        ];\n        const useOptionsReplaceForData = options.replace && !isString(options.replace);\n        let data = useOptionsReplaceForData ? options.replace : options;\n        if (useOptionsReplaceForData && typeof options.count !== \"undefined\") {\n            data.count = options.count;\n        }\n        if (this.options.interpolation.defaultVariables) {\n            data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n        }\n        if (!useOptionsReplaceForData) {\n            data = {\n                ...data\n            };\n            for (const key of optionsKeys){\n                delete data[key];\n            }\n        }\n        return data;\n    }\n    static hasDefaultValue(options) {\n        const prefix = \"defaultValue\";\n        for(const option in options){\n            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nclass LanguageUtil {\n    constructor(options){\n        this.options = options;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create(\"languageUtils\");\n    }\n    getScriptPartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return null;\n        const p = code.split(\"-\");\n        if (p.length === 2) return null;\n        p.pop();\n        if (p[p.length - 1].toLowerCase() === \"x\") return null;\n        return this.formatLanguageCode(p.join(\"-\"));\n    }\n    getLanguagePartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return code;\n        const p = code.split(\"-\");\n        return this.formatLanguageCode(p[0]);\n    }\n    formatLanguageCode(code) {\n        if (isString(code) && code.indexOf(\"-\") > -1) {\n            let formattedCode;\n            try {\n                formattedCode = Intl.getCanonicalLocales(code)[0];\n            } catch (e) {}\n            if (formattedCode && this.options.lowerCaseLng) {\n                formattedCode = formattedCode.toLowerCase();\n            }\n            if (formattedCode) return formattedCode;\n            if (this.options.lowerCaseLng) {\n                return code.toLowerCase();\n            }\n            return code;\n        }\n        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n    isSupportedCode(code) {\n        if (this.options.load === \"languageOnly\" || this.options.nonExplicitSupportedLngs) {\n            code = this.getLanguagePartFromCode(code);\n        }\n        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n    getBestMatchFromCodes(codes) {\n        if (!codes) return null;\n        let found;\n        codes.forEach((code)=>{\n            if (found) return;\n            const cleanedLng = this.formatLanguageCode(code);\n            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n        });\n        if (!found && this.options.supportedLngs) {\n            codes.forEach((code)=>{\n                if (found) return;\n                const lngScOnly = this.getScriptPartFromCode(code);\n                if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;\n                const lngOnly = this.getLanguagePartFromCode(code);\n                if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n                found = this.options.supportedLngs.find((supportedLng)=>{\n                    if (supportedLng === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(\"-\") < 0 && lngOnly.indexOf(\"-\") < 0) return;\n                    if (supportedLng.indexOf(\"-\") > 0 && lngOnly.indexOf(\"-\") < 0 && supportedLng.substring(0, supportedLng.indexOf(\"-\")) === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n                });\n            });\n        }\n        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n        return found;\n    }\n    getFallbackCodes(fallbacks, code) {\n        if (!fallbacks) return [];\n        if (typeof fallbacks === \"function\") fallbacks = fallbacks(code);\n        if (isString(fallbacks)) fallbacks = [\n            fallbacks\n        ];\n        if (Array.isArray(fallbacks)) return fallbacks;\n        if (!code) return fallbacks.default || [];\n        let found = fallbacks[code];\n        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n        if (!found) found = fallbacks[this.formatLanguageCode(code)];\n        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n        if (!found) found = fallbacks.default;\n        return found || [];\n    }\n    toResolveHierarchy(code, fallbackCode) {\n        const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);\n        const codes = [];\n        const addCode = (c)=>{\n            if (!c) return;\n            if (this.isSupportedCode(c)) {\n                codes.push(c);\n            } else {\n                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n            }\n        };\n        if (isString(code) && (code.indexOf(\"-\") > -1 || code.indexOf(\"_\") > -1)) {\n            if (this.options.load !== \"languageOnly\") addCode(this.formatLanguageCode(code));\n            if (this.options.load !== \"languageOnly\" && this.options.load !== \"currentOnly\") addCode(this.getScriptPartFromCode(code));\n            if (this.options.load !== \"currentOnly\") addCode(this.getLanguagePartFromCode(code));\n        } else if (isString(code)) {\n            addCode(this.formatLanguageCode(code));\n        }\n        fallbackCodes.forEach((fc)=>{\n            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n        });\n        return codes;\n    }\n}\nconst suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nconst dummyRule = {\n    select: (count)=>count === 1 ? \"one\" : \"other\",\n    resolvedOptions: ()=>({\n            pluralCategories: [\n                \"one\",\n                \"other\"\n            ]\n        })\n};\nclass PluralResolver {\n    constructor(languageUtils, options = {}){\n        this.languageUtils = languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"pluralResolver\");\n        this.pluralRulesCache = {};\n    }\n    addRule(lng, obj) {\n        this.rules[lng] = obj;\n    }\n    clearCache() {\n        this.pluralRulesCache = {};\n    }\n    getRule(code, options = {}) {\n        const cleanedCode = getCleanedCode(code === \"dev\" ? \"en\" : code);\n        const type = options.ordinal ? \"ordinal\" : \"cardinal\";\n        const cacheKey = JSON.stringify({\n            cleanedCode,\n            type\n        });\n        if (cacheKey in this.pluralRulesCache) {\n            return this.pluralRulesCache[cacheKey];\n        }\n        let rule;\n        try {\n            rule = new Intl.PluralRules(cleanedCode, {\n                type\n            });\n        } catch (err) {\n            if (!Intl) {\n                this.logger.error(\"No Intl support, please use an Intl polyfill!\");\n                return dummyRule;\n            }\n            if (!code.match(/-|_/)) return dummyRule;\n            const lngPart = this.languageUtils.getLanguagePartFromCode(code);\n            rule = this.getRule(lngPart, options);\n        }\n        this.pluralRulesCache[cacheKey] = rule;\n        return rule;\n    }\n    needsPlural(code, options = {}) {\n        let rule = this.getRule(code, options);\n        if (!rule) rule = this.getRule(\"dev\", options);\n        return rule?.resolvedOptions().pluralCategories.length > 1;\n    }\n    getPluralFormsOfKey(code, key, options = {}) {\n        return this.getSuffixes(code, options).map((suffix)=>`${key}${suffix}`);\n    }\n    getSuffixes(code, options = {}) {\n        let rule = this.getRule(code, options);\n        if (!rule) rule = this.getRule(\"dev\", options);\n        if (!rule) return [];\n        return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${pluralCategory}`);\n    }\n    getSuffix(code, count, options = {}) {\n        const rule = this.getRule(code, options);\n        if (rule) {\n            return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${rule.select(count)}`;\n        }\n        this.logger.warn(`no plural rule found for: ${code}`);\n        return this.getSuffix(\"dev\", count, options);\n    }\n}\nconst deepFindWithDefaults = (data, defaultData, key, keySeparator = \".\", ignoreJSONStructure = true)=>{\n    let path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && isString(key)) {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n};\nconst regexSafe = (val)=>val.replace(/\\$/g, \"$$$$\");\nclass Interpolator {\n    constructor(options = {}){\n        this.logger = baseLogger.create(\"interpolator\");\n        this.options = options;\n        this.format = options?.interpolation?.format || ((value)=>value);\n        this.init(options);\n    }\n    init(options = {}) {\n        if (!options.interpolation) options.interpolation = {\n            escapeValue: true\n        };\n        const { escape: escape$1, escapeValue, useRawValueToEscape, prefix, prefixEscaped, suffix, suffixEscaped, formatSeparator, unescapeSuffix, unescapePrefix, nestingPrefix, nestingPrefixEscaped, nestingSuffix, nestingSuffixEscaped, nestingOptionsSeparator, maxReplaces, alwaysFormat } = options.interpolation;\n        this.escape = escape$1 !== undefined ? escape$1 : escape;\n        this.escapeValue = escapeValue !== undefined ? escapeValue : true;\n        this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;\n        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || \"{{\";\n        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || \"}}\";\n        this.formatSeparator = formatSeparator || \",\";\n        this.unescapePrefix = unescapeSuffix ? \"\" : unescapePrefix || \"-\";\n        this.unescapeSuffix = this.unescapePrefix ? \"\" : unescapeSuffix || \"\";\n        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape(\"$t(\");\n        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(\")\");\n        this.nestingOptionsSeparator = nestingOptionsSeparator || \",\";\n        this.maxReplaces = maxReplaces || 1000;\n        this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;\n        this.resetRegExp();\n    }\n    reset() {\n        if (this.options) this.init(this.options);\n    }\n    resetRegExp() {\n        const getOrResetRegExp = (existingRegExp, pattern)=>{\n            if (existingRegExp?.source === pattern) {\n                existingRegExp.lastIndex = 0;\n                return existingRegExp;\n            }\n            return new RegExp(pattern, \"g\");\n        };\n        this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);\n        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);\n        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}((?:[^()\"']+|\"[^\"]*\"|'[^']*'|\\\\((?:[^()]|\"[^\"]*\"|'[^']*')*\\\\))*?)${this.nestingSuffix}`);\n    }\n    interpolate(str, data, lng, options) {\n        let match;\n        let value;\n        let replaces;\n        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n        const handleFormat = (key)=>{\n            if (key.indexOf(this.formatSeparator) < 0) {\n                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n                return this.alwaysFormat ? this.format(path, undefined, lng, {\n                    ...options,\n                    ...data,\n                    interpolationkey: key\n                }) : path;\n            }\n            const p = key.split(this.formatSeparator);\n            const k = p.shift().trim();\n            const f = p.join(this.formatSeparator).trim();\n            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n                ...options,\n                ...data,\n                interpolationkey: k\n            });\n        };\n        this.resetRegExp();\n        const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;\n        const skipOnVariables = options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n        const todos = [\n            {\n                regex: this.regexpUnescape,\n                safeValue: (val)=>regexSafe(val)\n            },\n            {\n                regex: this.regexp,\n                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n            }\n        ];\n        todos.forEach((todo)=>{\n            replaces = 0;\n            while(match = todo.regex.exec(str)){\n                const matchedVar = match[1].trim();\n                value = handleFormat(matchedVar);\n                if (value === undefined) {\n                    if (typeof missingInterpolationHandler === \"function\") {\n                        const temp = missingInterpolationHandler(str, match, options);\n                        value = isString(temp) ? temp : \"\";\n                    } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n                        value = \"\";\n                    } else if (skipOnVariables) {\n                        value = match[0];\n                        continue;\n                    } else {\n                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n                        value = \"\";\n                    }\n                } else if (!isString(value) && !this.useRawValueToEscape) {\n                    value = makeString(value);\n                }\n                const safeValue = todo.safeValue(value);\n                str = str.replace(match[0], safeValue);\n                if (skipOnVariables) {\n                    todo.regex.lastIndex += value.length;\n                    todo.regex.lastIndex -= match[0].length;\n                } else {\n                    todo.regex.lastIndex = 0;\n                }\n                replaces++;\n                if (replaces >= this.maxReplaces) {\n                    break;\n                }\n            }\n        });\n        return str;\n    }\n    nest(str, fc, options = {}) {\n        let match;\n        let value;\n        let clonedOptions;\n        const handleHasOptions = (key, inheritedOptions)=>{\n            const sep = this.nestingOptionsSeparator;\n            if (key.indexOf(sep) < 0) return key;\n            const c = key.split(new RegExp(`${sep}[ ]*{`));\n            let optionsString = `{${c[1]}`;\n            key = c[0];\n            optionsString = this.interpolate(optionsString, clonedOptions);\n            const matchedSingleQuotes = optionsString.match(/'/g);\n            const matchedDoubleQuotes = optionsString.match(/\"/g);\n            if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                optionsString = optionsString.replace(/'/g, '\"');\n            }\n            try {\n                clonedOptions = JSON.parse(optionsString);\n                if (inheritedOptions) clonedOptions = {\n                    ...inheritedOptions,\n                    ...clonedOptions\n                };\n            } catch (e) {\n                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n                return `${key}${sep}${optionsString}`;\n            }\n            if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;\n            return key;\n        };\n        while(match = this.nestingRegexp.exec(str)){\n            let formatters = [];\n            clonedOptions = {\n                ...options\n            };\n            clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf(\"}\") + 1 : match[1].indexOf(this.formatSeparator);\n            if (keyEndIndex !== -1) {\n                formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map((elem)=>elem.trim()).filter(Boolean);\n                match[1] = match[1].slice(0, keyEndIndex);\n            }\n            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n            if (value && match[0] === str && !isString(value)) return value;\n            if (!isString(value)) value = makeString(value);\n            if (!value) {\n                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n                value = \"\";\n            }\n            if (formatters.length) {\n                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {\n                        ...options,\n                        interpolationkey: match[1].trim()\n                    }), value.trim());\n            }\n            str = str.replace(match[0], value);\n            this.regexp.lastIndex = 0;\n        }\n        return str;\n    }\n}\nconst parseFormatStr = (formatStr)=>{\n    let formatName = formatStr.toLowerCase().trim();\n    const formatOptions = {};\n    if (formatStr.indexOf(\"(\") > -1) {\n        const p = formatStr.split(\"(\");\n        formatName = p[0].toLowerCase().trim();\n        const optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === \"currency\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === \"relativetime\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            const opts = optStr.split(\";\");\n            opts.forEach((opt)=>{\n                if (opt) {\n                    const [key, ...rest] = opt.split(\":\");\n                    const val = rest.join(\":\").trim().replace(/^'+|'+$/g, \"\");\n                    const trimmedKey = key.trim();\n                    if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;\n                    if (val === \"false\") formatOptions[trimmedKey] = false;\n                    if (val === \"true\") formatOptions[trimmedKey] = true;\n                    if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);\n                }\n            });\n        }\n    }\n    return {\n        formatName,\n        formatOptions\n    };\n};\nconst createCachedFormatter = (fn)=>{\n    const cache = {};\n    return (v, l, o)=>{\n        let optForCache = o;\n        if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {\n            optForCache = {\n                ...optForCache,\n                [o.interpolationkey]: undefined\n            };\n        }\n        const key = l + JSON.stringify(optForCache);\n        let frm = cache[key];\n        if (!frm) {\n            frm = fn(getCleanedCode(l), o);\n            cache[key] = frm;\n        }\n        return frm(v);\n    };\n};\nconst createNonCachedFormatter = (fn)=>(v, l, o)=>fn(getCleanedCode(l), o)(v);\nclass Formatter {\n    constructor(options = {}){\n        this.logger = baseLogger.create(\"formatter\");\n        this.options = options;\n        this.init(options);\n    }\n    init(services, options = {\n        interpolation: {}\n    }) {\n        this.formatSeparator = options.interpolation.formatSeparator || \",\";\n        const cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;\n        this.formats = {\n            number: cf((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            currency: cf((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt,\n                    style: \"currency\"\n                });\n                return (val)=>formatter.format(val);\n            }),\n            datetime: cf((lng, opt)=>{\n                const formatter = new Intl.DateTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            relativetime: cf((lng, opt)=>{\n                const formatter = new Intl.RelativeTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val, opt.range || \"day\");\n            }),\n            list: cf((lng, opt)=>{\n                const formatter = new Intl.ListFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            })\n        };\n    }\n    add(name, fc) {\n        this.formats[name.toLowerCase().trim()] = fc;\n    }\n    addCached(name, fc) {\n        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n    format(value, format, lng, options = {}) {\n        const formats = format.split(this.formatSeparator);\n        if (formats.length > 1 && formats[0].indexOf(\"(\") > 1 && formats[0].indexOf(\")\") < 0 && formats.find((f)=>f.indexOf(\")\") > -1)) {\n            const lastIndex = formats.findIndex((f)=>f.indexOf(\")\") > -1);\n            formats[0] = [\n                formats[0],\n                ...formats.splice(1, lastIndex)\n            ].join(this.formatSeparator);\n        }\n        const result = formats.reduce((mem, f)=>{\n            const { formatName, formatOptions } = parseFormatStr(f);\n            if (this.formats[formatName]) {\n                let formatted = mem;\n                try {\n                    const valOptions = options?.formatParams?.[options.interpolationkey] || {};\n                    const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n                    formatted = this.formats[formatName](mem, l, {\n                        ...formatOptions,\n                        ...options,\n                        ...valOptions\n                    });\n                } catch (error) {\n                    this.logger.warn(error);\n                }\n                return formatted;\n            } else {\n                this.logger.warn(`there was no format function for ${formatName}`);\n            }\n            return mem;\n        }, value);\n        return result;\n    }\n}\nconst removePending = (q, name)=>{\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n};\nclass Connector extends EventEmitter {\n    constructor(backend, store, services, options = {}){\n        super();\n        this.backend = backend;\n        this.store = store;\n        this.services = services;\n        this.languageUtils = services.languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"backendConnector\");\n        this.waitingReads = [];\n        this.maxParallelReads = options.maxParallelReads || 10;\n        this.readingCalls = 0;\n        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n        this.state = {};\n        this.queue = [];\n        this.backend?.init?.(services, options.backend, options);\n    }\n    queueLoad(languages, namespaces, options, callback) {\n        const toLoad = {};\n        const pending = {};\n        const toLoadLanguages = {};\n        const toLoadNamespaces = {};\n        languages.forEach((lng)=>{\n            let hasAllNamespaces = true;\n            namespaces.forEach((ns)=>{\n                const name = `${lng}|${ns}`;\n                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n                    this.state[name] = 2;\n                } else if (this.state[name] < 0) ;\n                else if (this.state[name] === 1) {\n                    if (pending[name] === undefined) pending[name] = true;\n                } else {\n                    this.state[name] = 1;\n                    hasAllNamespaces = false;\n                    if (pending[name] === undefined) pending[name] = true;\n                    if (toLoad[name] === undefined) toLoad[name] = true;\n                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                }\n            });\n            if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n        });\n        if (Object.keys(toLoad).length || Object.keys(pending).length) {\n            this.queue.push({\n                pending,\n                pendingCount: Object.keys(pending).length,\n                loaded: {},\n                errors: [],\n                callback\n            });\n        }\n        return {\n            toLoad: Object.keys(toLoad),\n            pending: Object.keys(pending),\n            toLoadLanguages: Object.keys(toLoadLanguages),\n            toLoadNamespaces: Object.keys(toLoadNamespaces)\n        };\n    }\n    loaded(name, err, data) {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        if (err) this.emit(\"failedLoading\", lng, ns, err);\n        if (!err && data) {\n            this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n                skipCopy: true\n            });\n        }\n        this.state[name] = err ? -1 : 2;\n        if (err && data) this.state[name] = 0;\n        const loaded = {};\n        this.queue.forEach((q)=>{\n            pushPath(q.loaded, [\n                lng\n            ], ns);\n            removePending(q, name);\n            if (err) q.errors.push(err);\n            if (q.pendingCount === 0 && !q.done) {\n                Object.keys(q.loaded).forEach((l)=>{\n                    if (!loaded[l]) loaded[l] = {};\n                    const loadedKeys = q.loaded[l];\n                    if (loadedKeys.length) {\n                        loadedKeys.forEach((n)=>{\n                            if (loaded[l][n] === undefined) loaded[l][n] = true;\n                        });\n                    }\n                });\n                q.done = true;\n                if (q.errors.length) {\n                    q.callback(q.errors);\n                } else {\n                    q.callback();\n                }\n            }\n        });\n        this.emit(\"loaded\", loaded);\n        this.queue = this.queue.filter((q)=>!q.done);\n    }\n    read(lng, ns, fcName, tried = 0, wait = this.retryTimeout, callback) {\n        if (!lng.length) return callback(null, {});\n        if (this.readingCalls >= this.maxParallelReads) {\n            this.waitingReads.push({\n                lng,\n                ns,\n                fcName,\n                tried,\n                wait,\n                callback\n            });\n            return;\n        }\n        this.readingCalls++;\n        const resolver = (err, data)=>{\n            this.readingCalls--;\n            if (this.waitingReads.length > 0) {\n                const next = this.waitingReads.shift();\n                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n            }\n            if (err && data && tried < this.maxRetries) {\n                setTimeout(()=>{\n                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                }, wait);\n                return;\n            }\n            callback(err, data);\n        };\n        const fc = this.backend[fcName].bind(this.backend);\n        if (fc.length === 2) {\n            try {\n                const r = fc(lng, ns);\n                if (r && typeof r.then === \"function\") {\n                    r.then((data)=>resolver(null, data)).catch(resolver);\n                } else {\n                    resolver(null, r);\n                }\n            } catch (err) {\n                resolver(err);\n            }\n            return;\n        }\n        return fc(lng, ns, resolver);\n    }\n    prepareLoading(languages, namespaces, options = {}, callback) {\n        if (!this.backend) {\n            this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\");\n            return callback && callback();\n        }\n        if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);\n        if (isString(namespaces)) namespaces = [\n            namespaces\n        ];\n        const toLoad = this.queueLoad(languages, namespaces, options, callback);\n        if (!toLoad.toLoad.length) {\n            if (!toLoad.pending.length) callback();\n            return null;\n        }\n        toLoad.toLoad.forEach((name)=>{\n            this.loadOne(name);\n        });\n    }\n    load(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {}, callback);\n    }\n    reload(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {\n            reload: true\n        }, callback);\n    }\n    loadOne(name, prefix = \"\") {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        this.read(lng, ns, \"read\", undefined, undefined, (err, data)=>{\n            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n            this.loaded(name, err, data);\n        });\n    }\n    saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}, clb = ()=>{}) {\n        if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {\n            this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n            return;\n        }\n        if (key === undefined || key === null || key === \"\") return;\n        if (this.backend?.create) {\n            const opts = {\n                ...options,\n                isUpdate\n            };\n            const fc = this.backend.create.bind(this.backend);\n            if (fc.length < 6) {\n                try {\n                    let r;\n                    if (fc.length === 5) {\n                        r = fc(languages, namespace, key, fallbackValue, opts);\n                    } else {\n                        r = fc(languages, namespace, key, fallbackValue);\n                    }\n                    if (r && typeof r.then === \"function\") {\n                        r.then((data)=>clb(null, data)).catch(clb);\n                    } else {\n                        clb(null, r);\n                    }\n                } catch (err) {\n                    clb(err);\n                }\n            } else {\n                fc(languages, namespace, key, fallbackValue, clb, opts);\n            }\n        }\n        if (!languages || !languages[0]) return;\n        this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n}\nconst get = ()=>({\n        debug: false,\n        initAsync: true,\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: [\n            \"translation\"\n        ],\n        fallbackLng: [\n            \"dev\"\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: \"all\",\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: \".\",\n        nsSeparator: \":\",\n        pluralSeparator: \"_\",\n        contextSeparator: \"_\",\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: \"fallback\",\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: (args)=>{\n            let ret = {};\n            if (typeof args[1] === \"object\") ret = args[1];\n            if (isString(args[1])) ret.defaultValue = args[1];\n            if (isString(args[2])) ret.tDescription = args[2];\n            if (typeof args[2] === \"object\" || typeof args[3] === \"object\") {\n                const options = args[3] || args[2];\n                Object.keys(options).forEach((key)=>{\n                    ret[key] = options[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: (value)=>value,\n            prefix: \"{{\",\n            suffix: \"}}\",\n            formatSeparator: \",\",\n            unescapePrefix: \"-\",\n            nestingPrefix: \"$t(\",\n            nestingSuffix: \")\",\n            nestingOptionsSeparator: \",\",\n            maxReplaces: 1000,\n            skipOnVariables: true\n        },\n        cacheInBuiltFormats: true\n    });\nconst transformOptions = (options)=>{\n    if (isString(options.ns)) options.ns = [\n        options.ns\n    ];\n    if (isString(options.fallbackLng)) options.fallbackLng = [\n        options.fallbackLng\n    ];\n    if (isString(options.fallbackNS)) options.fallbackNS = [\n        options.fallbackNS\n    ];\n    if (options.supportedLngs?.indexOf?.(\"cimode\") < 0) {\n        options.supportedLngs = options.supportedLngs.concat([\n            \"cimode\"\n        ]);\n    }\n    if (typeof options.initImmediate === \"boolean\") options.initAsync = options.initImmediate;\n    return options;\n};\nconst noop = ()=>{};\nconst bindMemberFunctions = (inst)=>{\n    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach((mem)=>{\n        if (typeof inst[mem] === \"function\") {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n};\nclass I18n extends EventEmitter {\n    constructor(options = {}, callback){\n        super();\n        this.options = transformOptions(options);\n        this.services = {};\n        this.logger = baseLogger;\n        this.modules = {\n            external: []\n        };\n        bindMemberFunctions(this);\n        if (callback && !this.isInitialized && !options.isClone) {\n            if (!this.options.initAsync) {\n                this.init(options, callback);\n                return this;\n            }\n            setTimeout(()=>{\n                this.init(options, callback);\n            }, 0);\n        }\n    }\n    init(options = {}, callback) {\n        this.isInitializing = true;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (options.defaultNS == null && options.ns) {\n            if (isString(options.ns)) {\n                options.defaultNS = options.ns;\n            } else if (options.ns.indexOf(\"translation\") < 0) {\n                options.defaultNS = options.ns[0];\n            }\n        }\n        const defOpts = get();\n        this.options = {\n            ...defOpts,\n            ...this.options,\n            ...transformOptions(options)\n        };\n        this.options.interpolation = {\n            ...defOpts.interpolation,\n            ...this.options.interpolation\n        };\n        if (options.keySeparator !== undefined) {\n            this.options.userDefinedKeySeparator = options.keySeparator;\n        }\n        if (options.nsSeparator !== undefined) {\n            this.options.userDefinedNsSeparator = options.nsSeparator;\n        }\n        const createClassOnDemand = (ClassOrObject)=>{\n            if (!ClassOrObject) return null;\n            if (typeof ClassOrObject === \"function\") return new ClassOrObject();\n            return ClassOrObject;\n        };\n        if (!this.options.isClone) {\n            if (this.modules.logger) {\n                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n            } else {\n                baseLogger.init(null, this.options);\n            }\n            let formatter;\n            if (this.modules.formatter) {\n                formatter = this.modules.formatter;\n            } else {\n                formatter = Formatter;\n            }\n            const lu = new LanguageUtil(this.options);\n            this.store = new ResourceStore(this.options.resources, this.options);\n            const s = this.services;\n            s.logger = baseLogger;\n            s.resourceStore = this.store;\n            s.languageUtils = lu;\n            s.pluralResolver = new PluralResolver(lu, {\n                prepend: this.options.pluralSeparator,\n                simplifyPluralSuffix: this.options.simplifyPluralSuffix\n            });\n            const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;\n            if (usingLegacyFormatFunction) {\n                this.logger.deprecate(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);\n            }\n            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                s.formatter = createClassOnDemand(formatter);\n                if (s.formatter.init) s.formatter.init(s, this.options);\n                this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n            }\n            s.interpolator = new Interpolator(this.options);\n            s.utils = {\n                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n            };\n            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n            s.backendConnector.on(\"*\", (event, ...args)=>{\n                this.emit(event, ...args);\n            });\n            if (this.modules.languageDetector) {\n                s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n            }\n            if (this.modules.i18nFormat) {\n                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                if (s.i18nFormat.init) s.i18nFormat.init(this);\n            }\n            this.translator = new Translator(this.services, this.options);\n            this.translator.on(\"*\", (event, ...args)=>{\n                this.emit(event, ...args);\n            });\n            this.modules.external.forEach((m)=>{\n                if (m.init) m.init(this);\n            });\n        }\n        this.format = this.options.interpolation.format;\n        if (!callback) callback = noop;\n        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n            if (codes.length > 0 && codes[0] !== \"dev\") this.options.lng = codes[0];\n        }\n        if (!this.services.languageDetector && !this.options.lng) {\n            this.logger.warn(\"init: no languageDetector is used and no lng is defined\");\n        }\n        const storeApi = [\n            \"getResource\",\n            \"hasResourceBundle\",\n            \"getResourceBundle\",\n            \"getDataByLanguage\"\n        ];\n        storeApi.forEach((fcName)=>{\n            this[fcName] = (...args)=>this.store[fcName](...args);\n        });\n        const storeApiChained = [\n            \"addResource\",\n            \"addResources\",\n            \"addResourceBundle\",\n            \"removeResourceBundle\"\n        ];\n        storeApiChained.forEach((fcName)=>{\n            this[fcName] = (...args)=>{\n                this.store[fcName](...args);\n                return this;\n            };\n        });\n        const deferred = defer();\n        const load = ()=>{\n            const finish = (err, t)=>{\n                this.isInitializing = false;\n                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn(\"init: i18next is already initialized. You should call init just once!\");\n                this.isInitialized = true;\n                if (!this.options.isClone) this.logger.log(\"initialized\", this.options);\n                this.emit(\"initialized\", this.options);\n                deferred.resolve(t);\n                callback(err, t);\n            };\n            if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));\n            this.changeLanguage(this.options.lng, finish);\n        };\n        if (this.options.resources || !this.options.initAsync) {\n            load();\n        } else {\n            setTimeout(load, 0);\n        }\n        return deferred;\n    }\n    loadResources(language, callback = noop) {\n        let usedCallback = callback;\n        const usedLng = isString(language) ? language : this.language;\n        if (typeof language === \"function\") usedCallback = language;\n        if (!this.options.resources || this.options.partialBundledLanguages) {\n            if (usedLng?.toLowerCase() === \"cimode\" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n            const toLoad = [];\n            const append = (lng)=>{\n                if (!lng) return;\n                if (lng === \"cimode\") return;\n                const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                lngs.forEach((l)=>{\n                    if (l === \"cimode\") return;\n                    if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                });\n            };\n            if (!usedLng) {\n                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                fallbacks.forEach((l)=>append(l));\n            } else {\n                append(usedLng);\n            }\n            this.options.preload?.forEach?.((l)=>append(l));\n            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{\n                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n                usedCallback(e);\n            });\n        } else {\n            usedCallback(null);\n        }\n    }\n    reloadResources(lngs, ns, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"function\") {\n            callback = lngs;\n            lngs = undefined;\n        }\n        if (typeof ns === \"function\") {\n            callback = ns;\n            ns = undefined;\n        }\n        if (!lngs) lngs = this.languages;\n        if (!ns) ns = this.options.ns;\n        if (!callback) callback = noop;\n        this.services.backendConnector.reload(lngs, ns, (err)=>{\n            deferred.resolve();\n            callback(err);\n        });\n        return deferred;\n    }\n    use(module) {\n        if (!module) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\");\n        if (!module.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\");\n        if (module.type === \"backend\") {\n            this.modules.backend = module;\n        }\n        if (module.type === \"logger\" || module.log && module.warn && module.error) {\n            this.modules.logger = module;\n        }\n        if (module.type === \"languageDetector\") {\n            this.modules.languageDetector = module;\n        }\n        if (module.type === \"i18nFormat\") {\n            this.modules.i18nFormat = module;\n        }\n        if (module.type === \"postProcessor\") {\n            postProcessor.addPostProcessor(module);\n        }\n        if (module.type === \"formatter\") {\n            this.modules.formatter = module;\n        }\n        if (module.type === \"3rdParty\") {\n            this.modules.external.push(module);\n        }\n        return this;\n    }\n    setResolvedLanguage(l) {\n        if (!l || !this.languages) return;\n        if ([\n            \"cimode\",\n            \"dev\"\n        ].indexOf(l) > -1) return;\n        for(let li = 0; li < this.languages.length; li++){\n            const lngInLngs = this.languages[li];\n            if ([\n                \"cimode\",\n                \"dev\"\n            ].indexOf(lngInLngs) > -1) continue;\n            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                this.resolvedLanguage = lngInLngs;\n                break;\n            }\n        }\n        if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {\n            this.resolvedLanguage = l;\n            this.languages.unshift(l);\n        }\n    }\n    changeLanguage(lng, callback) {\n        this.isLanguageChangingTo = lng;\n        const deferred = defer();\n        this.emit(\"languageChanging\", lng);\n        const setLngProps = (l)=>{\n            this.language = l;\n            this.languages = this.services.languageUtils.toResolveHierarchy(l);\n            this.resolvedLanguage = undefined;\n            this.setResolvedLanguage(l);\n        };\n        const done = (err, l)=>{\n            if (l) {\n                if (this.isLanguageChangingTo === lng) {\n                    setLngProps(l);\n                    this.translator.changeLanguage(l);\n                    this.isLanguageChangingTo = undefined;\n                    this.emit(\"languageChanged\", l);\n                    this.logger.log(\"languageChanged\", l);\n                }\n            } else {\n                this.isLanguageChangingTo = undefined;\n            }\n            deferred.resolve((...args)=>this.t(...args));\n            if (callback) callback(err, (...args)=>this.t(...args));\n        };\n        const setLng = (lngs)=>{\n            if (!lng && !lngs && this.services.languageDetector) lngs = [];\n            const fl = isString(lngs) ? lngs : lngs && lngs[0];\n            const l = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [\n                lngs\n            ] : lngs);\n            if (l) {\n                if (!this.language) {\n                    setLngProps(l);\n                }\n                if (!this.translator.language) this.translator.changeLanguage(l);\n                this.services.languageDetector?.cacheUserLanguage?.(l);\n            }\n            this.loadResources(l, (err)=>{\n                done(err, l);\n            });\n        };\n        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n            setLng(this.services.languageDetector.detect());\n        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n            if (this.services.languageDetector.detect.length === 0) {\n                this.services.languageDetector.detect().then(setLng);\n            } else {\n                this.services.languageDetector.detect(setLng);\n            }\n        } else {\n            setLng(lng);\n        }\n        return deferred;\n    }\n    getFixedT(lng, ns, keyPrefix) {\n        const fixedT = (key, opts, ...rest)=>{\n            let o;\n            if (typeof opts !== \"object\") {\n                o = this.options.overloadTranslationOptionHandler([\n                    key,\n                    opts\n                ].concat(rest));\n            } else {\n                o = {\n                    ...opts\n                };\n            }\n            o.lng = o.lng || fixedT.lng;\n            o.lngs = o.lngs || fixedT.lngs;\n            o.ns = o.ns || fixedT.ns;\n            if (o.keyPrefix !== \"\") o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;\n            const keySeparator = this.options.keySeparator || \".\";\n            let resultKey;\n            if (o.keyPrefix && Array.isArray(key)) {\n                resultKey = key.map((k)=>{\n                    if (typeof k === \"function\") k = keysFromSelector(k, {\n                        ...this.options,\n                        ...opts\n                    });\n                    return `${o.keyPrefix}${keySeparator}${k}`;\n                });\n            } else {\n                if (typeof key === \"function\") key = keysFromSelector(key, {\n                    ...this.options,\n                    ...opts\n                });\n                resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;\n            }\n            return this.t(resultKey, o);\n        };\n        if (isString(lng)) {\n            fixedT.lng = lng;\n        } else {\n            fixedT.lngs = lng;\n        }\n        fixedT.ns = ns;\n        fixedT.keyPrefix = keyPrefix;\n        return fixedT;\n    }\n    t(...args) {\n        return this.translator?.translate(...args);\n    }\n    exists(...args) {\n        return this.translator?.exists(...args);\n    }\n    setDefaultNamespace(ns) {\n        this.options.defaultNS = ns;\n    }\n    hasLoadedNamespace(ns, options = {}) {\n        if (!this.isInitialized) {\n            this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages);\n            return false;\n        }\n        if (!this.languages || !this.languages.length) {\n            this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages);\n            return false;\n        }\n        const lng = options.lng || this.resolvedLanguage || this.languages[0];\n        const fallbackLng = this.options ? this.options.fallbackLng : false;\n        const lastLng = this.languages[this.languages.length - 1];\n        if (lng.toLowerCase() === \"cimode\") return true;\n        const loadNotPending = (l, n)=>{\n            const loadState = this.services.backendConnector.state[`${l}|${n}`];\n            return loadState === -1 || loadState === 0 || loadState === 2;\n        };\n        if (options.precheck) {\n            const preResult = options.precheck(this, loadNotPending);\n            if (preResult !== undefined) return preResult;\n        }\n        if (this.hasResourceBundle(lng, ns)) return true;\n        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n        return false;\n    }\n    loadNamespaces(ns, callback) {\n        const deferred = defer();\n        if (!this.options.ns) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        if (isString(ns)) ns = [\n            ns\n        ];\n        ns.forEach((n)=>{\n            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n        });\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    loadLanguages(lngs, callback) {\n        const deferred = defer();\n        if (isString(lngs)) lngs = [\n            lngs\n        ];\n        const preloaded = this.options.preload || [];\n        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));\n        if (!newLngs.length) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        this.options.preload = preloaded.concat(newLngs);\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    dir(lng) {\n        if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);\n        if (!lng) return \"rtl\";\n        try {\n            const l = new Intl.Locale(lng);\n            if (l && l.getTextInfo) {\n                const ti = l.getTextInfo();\n                if (ti && ti.direction) return ti.direction;\n            }\n        } catch (e) {}\n        const rtlLngs = [\n            \"ar\",\n            \"shu\",\n            \"sqr\",\n            \"ssh\",\n            \"xaa\",\n            \"yhd\",\n            \"yud\",\n            \"aao\",\n            \"abh\",\n            \"abv\",\n            \"acm\",\n            \"acq\",\n            \"acw\",\n            \"acx\",\n            \"acy\",\n            \"adf\",\n            \"ads\",\n            \"aeb\",\n            \"aec\",\n            \"afb\",\n            \"ajp\",\n            \"apc\",\n            \"apd\",\n            \"arb\",\n            \"arq\",\n            \"ars\",\n            \"ary\",\n            \"arz\",\n            \"auz\",\n            \"avl\",\n            \"ayh\",\n            \"ayl\",\n            \"ayn\",\n            \"ayp\",\n            \"bbz\",\n            \"pga\",\n            \"he\",\n            \"iw\",\n            \"ps\",\n            \"pbt\",\n            \"pbu\",\n            \"pst\",\n            \"prp\",\n            \"prd\",\n            \"ug\",\n            \"ur\",\n            \"ydd\",\n            \"yds\",\n            \"yih\",\n            \"ji\",\n            \"yi\",\n            \"hbo\",\n            \"men\",\n            \"xmn\",\n            \"fa\",\n            \"jpr\",\n            \"peo\",\n            \"pes\",\n            \"prs\",\n            \"dv\",\n            \"sam\",\n            \"ckb\"\n        ];\n        const languageUtils = this.services?.languageUtils || new LanguageUtil(get());\n        if (lng.toLowerCase().indexOf(\"-latn\") > 1) return \"ltr\";\n        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\";\n    }\n    static createInstance(options = {}, callback) {\n        return new I18n(options, callback);\n    }\n    cloneInstance(options = {}, callback = noop) {\n        const forkResourceStore = options.forkResourceStore;\n        if (forkResourceStore) delete options.forkResourceStore;\n        const mergedOptions = {\n            ...this.options,\n            ...options,\n            ...{\n                isClone: true\n            }\n        };\n        const clone = new I18n(mergedOptions);\n        if (options.debug !== undefined || options.prefix !== undefined) {\n            clone.logger = clone.logger.clone(options);\n        }\n        const membersToCopy = [\n            \"store\",\n            \"services\",\n            \"language\"\n        ];\n        membersToCopy.forEach((m)=>{\n            clone[m] = this[m];\n        });\n        clone.services = {\n            ...this.services\n        };\n        clone.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        if (forkResourceStore) {\n            const clonedData = Object.keys(this.store.data).reduce((prev, l)=>{\n                prev[l] = {\n                    ...this.store.data[l]\n                };\n                prev[l] = Object.keys(prev[l]).reduce((acc, n)=>{\n                    acc[n] = {\n                        ...prev[l][n]\n                    };\n                    return acc;\n                }, prev[l]);\n                return prev;\n            }, {});\n            clone.store = new ResourceStore(clonedData, mergedOptions);\n            clone.services.resourceStore = clone.store;\n        }\n        clone.translator = new Translator(clone.services, mergedOptions);\n        clone.translator.on(\"*\", (event, ...args)=>{\n            clone.emit(event, ...args);\n        });\n        clone.init(mergedOptions, callback);\n        clone.translator.options = mergedOptions;\n        clone.translator.backendConnector.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        return clone;\n    }\n    toJSON() {\n        return {\n            options: this.options,\n            store: this.store,\n            language: this.language,\n            languages: this.languages,\n            resolvedLanguage: this.resolvedLanguage\n        };\n    }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNQSxXQUFXQyxDQUFBQSxNQUFPLE9BQU9BLFFBQVE7QUFDdkMsTUFBTUMsUUFBUTtJQUNaLElBQUlDO0lBQ0osSUFBSUM7SUFDSixNQUFNQyxVQUFVLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDcENMLE1BQU1JO1FBQ05ILE1BQU1JO0lBQ1I7SUFDQUgsUUFBUUUsT0FBTyxHQUFHSjtJQUNsQkUsUUFBUUcsTUFBTSxHQUFHSjtJQUNqQixPQUFPQztBQUNUO0FBQ0EsTUFBTUksYUFBYUMsQ0FBQUE7SUFDakIsSUFBSUEsVUFBVSxNQUFNLE9BQU87SUFDM0IsT0FBTyxLQUFLQTtBQUNkO0FBQ0EsTUFBTUMsT0FBTyxDQUFDQyxHQUFHQyxHQUFHQztJQUNsQkYsRUFBRUcsT0FBTyxDQUFDQyxDQUFBQTtRQUNSLElBQUlILENBQUMsQ0FBQ0csRUFBRSxFQUFFRixDQUFDLENBQUNFLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ3ZCO0FBQ0Y7QUFDQSxNQUFNQyw0QkFBNEI7QUFDbEMsTUFBTUMsV0FBV0MsQ0FBQUEsTUFBT0EsT0FBT0EsSUFBSUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJRCxJQUFJRSxPQUFPLENBQUNKLDJCQUEyQixPQUFPRTtBQUN2RyxNQUFNRyx1QkFBdUJaLENBQUFBLFNBQVUsQ0FBQ0EsVUFBVVYsU0FBU1U7QUFDM0QsTUFBTWEsZ0JBQWdCLENBQUNiLFFBQVFjLE1BQU1DO0lBQ25DLE1BQU1DLFFBQVEsQ0FBQzFCLFNBQVN3QixRQUFRQSxPQUFPQSxLQUFLRyxLQUFLLENBQUM7SUFDbEQsSUFBSUMsYUFBYTtJQUNqQixNQUFPQSxhQUFhRixNQUFNRyxNQUFNLEdBQUcsRUFBRztRQUNwQyxJQUFJUCxxQkFBcUJaLFNBQVMsT0FBTyxDQUFDO1FBQzFDLE1BQU1TLE1BQU1E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QUFNeGMsT0FBT3NkLFNBQVN0ZCxJQUFJO0FBQzFCLE1BQU13YSxnQkFBZ0I4QyxTQUFTOUMsYUFBYTtBQUM1QyxNQUFNSyxrQkFBa0J5QyxTQUFTekMsZUFBZTtBQUNoRCxNQUFNQyxNQUFNd0MsU0FBU3hDLEdBQUc7QUFDeEIsTUFBTXpWLGlCQUFpQmlZLFNBQVNqWSxjQUFjO0FBQzlDLE1BQU1xVyxZQUFZNEIsU0FBUzVCLFNBQVM7QUFDcEMsTUFBTTNoQixJQUFJdWpCLFNBQVN2akIsQ0FBQztBQUNwQixNQUFNd0wsU0FBUytYLFNBQVMvWCxNQUFNO0FBQzlCLE1BQU11VyxzQkFBc0J3QixTQUFTeEIsbUJBQW1CO0FBQ3hELE1BQU05UCxxQkFBcUJzUixTQUFTdFIsa0JBQWtCO0FBQ3RELE1BQU1vUSxpQkFBaUJrQixTQUFTbEIsY0FBYztBQUM5QyxNQUFNQyxnQkFBZ0JpQixTQUFTakIsYUFBYTtBQUVzTSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0b2NrLXNhYXMvLi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzPzY4ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXNTdHJpbmcgPSBvYmogPT4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG5jb25zdCBkZWZlciA9ICgpID0+IHtcbiAgbGV0IHJlcztcbiAgbGV0IHJlajtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXMgPSByZXNvbHZlO1xuICAgIHJlaiA9IHJlamVjdDtcbiAgfSk7XG4gIHByb21pc2UucmVzb2x2ZSA9IHJlcztcbiAgcHJvbWlzZS5yZWplY3QgPSByZWo7XG4gIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IG1ha2VTdHJpbmcgPSBvYmplY3QgPT4ge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAnJztcbiAgcmV0dXJuICcnICsgb2JqZWN0O1xufTtcbmNvbnN0IGNvcHkgPSAoYSwgcywgdCkgPT4ge1xuICBhLmZvckVhY2gobSA9PiB7XG4gICAgaWYgKHNbbV0pIHRbbV0gPSBzW21dO1xuICB9KTtcbn07XG5jb25zdCBsYXN0T2ZQYXRoU2VwYXJhdG9yUmVnRXhwID0gLyMjIy9nO1xuY29uc3QgY2xlYW5LZXkgPSBrZXkgPT4ga2V5ICYmIGtleS5pbmRleE9mKCcjIyMnKSA+IC0xID8ga2V5LnJlcGxhY2UobGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCwgJy4nKSA6IGtleTtcbmNvbnN0IGNhbk5vdFRyYXZlcnNlRGVlcGVyID0gb2JqZWN0ID0+ICFvYmplY3QgfHwgaXNTdHJpbmcob2JqZWN0KTtcbmNvbnN0IGdldExhc3RPZlBhdGggPSAob2JqZWN0LCBwYXRoLCBFbXB0eSkgPT4ge1xuICBjb25zdCBzdGFjayA9ICFpc1N0cmluZyhwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCBzdGFja0luZGV4ID0gMDtcbiAgd2hpbGUgKHN0YWNrSW5kZXggPCBzdGFjay5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGNhbk5vdFRyYXZlcnNlRGVlcGVyKG9iamVjdCkpIHJldHVybiB7fTtcbiAgICBjb25zdCBrZXkgPSBjbGVhbktleShzdGFja1tzdGFja0luZGV4XSk7XG4gICAgaWYgKCFvYmplY3Rba2V5XSAmJiBFbXB0eSkgb2JqZWN0W2tleV0gPSBuZXcgRW1wdHkoKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IHt9O1xuICAgIH1cbiAgICArK3N0YWNrSW5kZXg7XG4gIH1cbiAgaWYgKGNhbk5vdFRyYXZlcnNlRGVlcGVyKG9iamVjdCkpIHJldHVybiB7fTtcbiAgcmV0dXJuIHtcbiAgICBvYmo6IG9iamVjdCxcbiAgICBrOiBjbGVhbktleShzdGFja1tzdGFja0luZGV4XSlcbiAgfTtcbn07XG5jb25zdCBzZXRQYXRoID0gKG9iamVjdCwgcGF0aCwgbmV3VmFsdWUpID0+IHtcbiAgY29uc3Qge1xuICAgIG9iaixcbiAgICBrXG4gIH0gPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgT2JqZWN0KTtcbiAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkIHx8IHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgb2JqW2tdID0gbmV3VmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICBsZXQgcCA9IHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgbGV0IGxhc3QgPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcCwgT2JqZWN0KTtcbiAgd2hpbGUgKGxhc3Qub2JqID09PSB1bmRlZmluZWQgJiYgcC5sZW5ndGgpIHtcbiAgICBlID0gYCR7cFtwLmxlbmd0aCAtIDFdfS4ke2V9YDtcbiAgICBwID0gcC5zbGljZSgwLCBwLmxlbmd0aCAtIDEpO1xuICAgIGxhc3QgPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcCwgT2JqZWN0KTtcbiAgICBpZiAobGFzdD8ub2JqICYmIHR5cGVvZiBsYXN0Lm9ialtgJHtsYXN0Lmt9LiR7ZX1gXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxhc3Qub2JqID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBsYXN0Lm9ialtgJHtsYXN0Lmt9LiR7ZX1gXSA9IG5ld1ZhbHVlO1xufTtcbmNvbnN0IHB1c2hQYXRoID0gKG9iamVjdCwgcGF0aCwgbmV3VmFsdWUsIGNvbmNhdCkgPT4ge1xuICBjb25zdCB7XG4gICAgb2JqLFxuICAgIGtcbiAgfSA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoLCBPYmplY3QpO1xuICBvYmpba10gPSBvYmpba10gfHwgW107XG4gIG9ialtrXS5wdXNoKG5ld1ZhbHVlKTtcbn07XG5jb25zdCBnZXRQYXRoID0gKG9iamVjdCwgcGF0aCkgPT4ge1xuICBjb25zdCB7XG4gICAgb2JqLFxuICAgIGtcbiAgfSA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoKTtcbiAgaWYgKCFvYmopIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBvYmpba107XG59O1xuY29uc3QgZ2V0UGF0aFdpdGhEZWZhdWx0cyA9IChkYXRhLCBkZWZhdWx0RGF0YSwga2V5KSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0UGF0aChkYXRhLCBrZXkpO1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gZ2V0UGF0aChkZWZhdWx0RGF0YSwga2V5KTtcbn07XG5jb25zdCBkZWVwRXh0ZW5kID0gKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpID0+IHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgIGlmIChwcm9wICE9PSAnX19wcm90b19fJyAmJiBwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICBpZiAocHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHRhcmdldFtwcm9wXSkgfHwgdGFyZ2V0W3Byb3BdIGluc3RhbmNlb2YgU3RyaW5nIHx8IGlzU3RyaW5nKHNvdXJjZVtwcm9wXSkgfHwgc291cmNlW3Byb3BdIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgaWYgKG92ZXJ3cml0ZSkgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZXBFeHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0sIG92ZXJ3cml0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5jb25zdCByZWdleEVzY2FwZSA9IHN0ciA9PiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXFxcJCYnKTtcbnZhciBfZW50aXR5TWFwID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnLFxuICAnLyc6ICcmI3gyRjsnXG59O1xuY29uc3QgZXNjYXBlID0gZGF0YSA9PiB7XG4gIGlmIChpc1N0cmluZyhkYXRhKSkge1xuICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL1smPD5cIidcXC9dL2csIHMgPT4gX2VudGl0eU1hcFtzXSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59O1xuY2xhc3MgUmVnRXhwQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihjYXBhY2l0eSkge1xuICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLnJlZ0V4cE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlZ0V4cFF1ZXVlID0gW107XG4gIH1cbiAgZ2V0UmVnRXhwKHBhdHRlcm4pIHtcbiAgICBjb25zdCByZWdFeHBGcm9tQ2FjaGUgPSB0aGlzLnJlZ0V4cE1hcC5nZXQocGF0dGVybik7XG4gICAgaWYgKHJlZ0V4cEZyb21DYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVnRXhwRnJvbUNhY2hlO1xuICAgIH1cbiAgICBjb25zdCByZWdFeHBOZXcgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICAgIGlmICh0aGlzLnJlZ0V4cFF1ZXVlLmxlbmd0aCA9PT0gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgdGhpcy5yZWdFeHBNYXAuZGVsZXRlKHRoaXMucmVnRXhwUXVldWUuc2hpZnQoKSk7XG4gICAgfVxuICAgIHRoaXMucmVnRXhwTWFwLnNldChwYXR0ZXJuLCByZWdFeHBOZXcpO1xuICAgIHRoaXMucmVnRXhwUXVldWUucHVzaChwYXR0ZXJuKTtcbiAgICByZXR1cm4gcmVnRXhwTmV3O1xuICB9XG59XG5jb25zdCBjaGFycyA9IFsnICcsICcsJywgJz8nLCAnIScsICc7J107XG5jb25zdCBsb29rc0xpa2VPYmplY3RQYXRoUmVnRXhwQ2FjaGUgPSBuZXcgUmVnRXhwQ2FjaGUoMjApO1xuY29uc3QgbG9va3NMaWtlT2JqZWN0UGF0aCA9IChrZXksIG5zU2VwYXJhdG9yLCBrZXlTZXBhcmF0b3IpID0+IHtcbiAgbnNTZXBhcmF0b3IgPSBuc1NlcGFyYXRvciB8fCAnJztcbiAga2V5U2VwYXJhdG9yID0ga2V5U2VwYXJhdG9yIHx8ICcnO1xuICBjb25zdCBwb3NzaWJsZUNoYXJzID0gY2hhcnMuZmlsdGVyKGMgPT4gbnNTZXBhcmF0b3IuaW5kZXhPZihjKSA8IDAgJiYga2V5U2VwYXJhdG9yLmluZGV4T2YoYykgPCAwKTtcbiAgaWYgKHBvc3NpYmxlQ2hhcnMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgciA9IGxvb2tzTGlrZU9iamVjdFBhdGhSZWdFeHBDYWNoZS5nZXRSZWdFeHAoYCgke3Bvc3NpYmxlQ2hhcnMubWFwKGMgPT4gYyA9PT0gJz8nID8gJ1xcXFw/JyA6IGMpLmpvaW4oJ3wnKX0pYCk7XG4gIGxldCBtYXRjaGVkID0gIXIudGVzdChrZXkpO1xuICBpZiAoIW1hdGNoZWQpIHtcbiAgICBjb25zdCBraSA9IGtleS5pbmRleE9mKGtleVNlcGFyYXRvcik7XG4gICAgaWYgKGtpID4gMCAmJiAhci50ZXN0KGtleS5zdWJzdHJpbmcoMCwga2kpKSkge1xuICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVkO1xufTtcbmNvbnN0IGRlZXBGaW5kID0gKG9iaiwgcGF0aCwga2V5U2VwYXJhdG9yID0gJy4nKSA9PiB7XG4gIGlmICghb2JqKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAob2JqW3BhdGhdKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwYXRoKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gb2JqW3BhdGhdO1xuICB9XG4gIGNvbnN0IHRva2VucyA9IHBhdGguc3BsaXQoa2V5U2VwYXJhdG9yKTtcbiAgbGV0IGN1cnJlbnQgPSBvYmo7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDspIHtcbiAgICBpZiAoIWN1cnJlbnQgfHwgdHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgbmV4dDtcbiAgICBsZXQgbmV4dFBhdGggPSAnJztcbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRva2Vucy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGogIT09IGkpIHtcbiAgICAgICAgbmV4dFBhdGggKz0ga2V5U2VwYXJhdG9yO1xuICAgICAgfVxuICAgICAgbmV4dFBhdGggKz0gdG9rZW5zW2pdO1xuICAgICAgbmV4dCA9IGN1cnJlbnRbbmV4dFBhdGhdO1xuICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXS5pbmRleE9mKHR5cGVvZiBuZXh0KSA+IC0xICYmIGogPCB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gaiAtIGkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59O1xuY29uc3QgZ2V0Q2xlYW5lZENvZGUgPSBjb2RlID0+IGNvZGU/LnJlcGxhY2UoJ18nLCAnLScpO1xuXG5jb25zdCBjb25zb2xlTG9nZ2VyID0ge1xuICB0eXBlOiAnbG9nZ2VyJyxcbiAgbG9nKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnbG9nJywgYXJncyk7XG4gIH0sXG4gIHdhcm4oYXJncykge1xuICAgIHRoaXMub3V0cHV0KCd3YXJuJywgYXJncyk7XG4gIH0sXG4gIGVycm9yKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnZXJyb3InLCBhcmdzKTtcbiAgfSxcbiAgb3V0cHV0KHR5cGUsIGFyZ3MpIHtcbiAgICBjb25zb2xlPy5bdHlwZV0/LmFwcGx5Py4oY29uc29sZSwgYXJncyk7XG4gIH1cbn07XG5jbGFzcyBMb2dnZXIge1xuICBjb25zdHJ1Y3Rvcihjb25jcmV0ZUxvZ2dlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5pbml0KGNvbmNyZXRlTG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxuICBpbml0KGNvbmNyZXRlTG9nZ2VyLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8ICdpMThuZXh0Oic7XG4gICAgdGhpcy5sb2dnZXIgPSBjb25jcmV0ZUxvZ2dlciB8fCBjb25zb2xlTG9nZ2VyO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gIH1cbiAgbG9nKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICdsb2cnLCAnJywgdHJ1ZSk7XG4gIH1cbiAgd2FybiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnd2FybicsICcnLCB0cnVlKTtcbiAgfVxuICBlcnJvciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnZXJyb3InLCAnJyk7XG4gIH1cbiAgZGVwcmVjYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICd3YXJuJywgJ1dBUk5JTkcgREVQUkVDQVRFRDogJywgdHJ1ZSk7XG4gIH1cbiAgZm9yd2FyZChhcmdzLCBsdmwsIHByZWZpeCwgZGVidWdPbmx5KSB7XG4gICAgaWYgKGRlYnVnT25seSAmJiAhdGhpcy5kZWJ1ZykgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlzU3RyaW5nKGFyZ3NbMF0pKSBhcmdzWzBdID0gYCR7cHJlZml4fSR7dGhpcy5wcmVmaXh9ICR7YXJnc1swXX1gO1xuICAgIHJldHVybiB0aGlzLmxvZ2dlcltsdmxdKGFyZ3MpO1xuICB9XG4gIGNyZWF0ZShtb2R1bGVOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBMb2dnZXIodGhpcy5sb2dnZXIsIHtcbiAgICAgIC4uLntcbiAgICAgICAgcHJlZml4OiBgJHt0aGlzLnByZWZpeH06JHttb2R1bGVOYW1lfTpgXG4gICAgICB9LFxuICAgICAgLi4udGhpcy5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucztcbiAgICBvcHRpb25zLnByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8IHRoaXMucHJlZml4O1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMubG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxufVxudmFyIGJhc2VMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub2JzZXJ2ZXJzID0ge307XG4gIH1cbiAgb24oZXZlbnRzLCBsaXN0ZW5lcikge1xuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgaWYgKCF0aGlzLm9ic2VydmVyc1tldmVudF0pIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IG51bUxpc3RlbmVycyA9IHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5nZXQobGlzdGVuZXIpIHx8IDA7XG4gICAgICB0aGlzLm9ic2VydmVyc1tldmVudF0uc2V0KGxpc3RlbmVyLCBudW1MaXN0ZW5lcnMgKyAxKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVyc1tldmVudF0pIHJldHVybjtcbiAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbZXZlbnRdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVyc1tldmVudF0uZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gQXJyYXkuZnJvbSh0aGlzLm9ic2VydmVyc1tldmVudF0uZW50cmllcygpKTtcbiAgICAgIGNsb25lZC5mb3JFYWNoKChbb2JzZXJ2ZXIsIG51bVRpbWVzQWRkZWRdKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVGltZXNBZGRlZDsgaSsrKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vYnNlcnZlcnNbJyonXSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gQXJyYXkuZnJvbSh0aGlzLm9ic2VydmVyc1snKiddLmVudHJpZXMoKSk7XG4gICAgICBjbG9uZWQuZm9yRWFjaCgoW29ic2VydmVyLCBudW1UaW1lc0FkZGVkXSkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpbWVzQWRkZWQ7IGkrKykge1xuICAgICAgICAgIG9ic2VydmVyLmFwcGx5KG9ic2VydmVyLCBbZXZlbnQsIC4uLmFyZ3NdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFJlc291cmNlU3RvcmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge1xuICAgIG5zOiBbJ3RyYW5zbGF0aW9uJ10sXG4gICAgZGVmYXVsdE5TOiAndHJhbnNsYXRpb24nXG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID0gJy4nO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhZGROYW1lc3BhY2VzKG5zKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKSA8IDApIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ucy5wdXNoKG5zKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTmFtZXNwYWNlcyhucykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcHRpb25zLm5zLmluZGV4T2YobnMpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVzb3VyY2UobG5nLCBucywga2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGNvbnN0IGlnbm9yZUpTT05TdHJ1Y3R1cmUgPSBvcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSA6IHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlO1xuICAgIGxldCBwYXRoO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IFtsbmcsIG5zXTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgIHBhdGgucHVzaCguLi5rZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGtleSkgJiYga2V5U2VwYXJhdG9yKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKC4uLmtleS5zcGxpdChrZXlTZXBhcmF0b3IpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBnZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCk7XG4gICAgaWYgKCFyZXN1bHQgJiYgIW5zICYmICFrZXkgJiYgbG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBsbmcgPSBwYXRoWzBdO1xuICAgICAgbnMgPSBwYXRoWzFdO1xuICAgICAga2V5ID0gcGF0aC5zbGljZSgyKS5qb2luKCcuJyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgfHwgIWlnbm9yZUpTT05TdHJ1Y3R1cmUgfHwgIWlzU3RyaW5nKGtleSkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIGRlZXBGaW5kKHRoaXMuZGF0YT8uW2xuZ10/Lltuc10sIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgfVxuICBhZGRSZXNvdXJjZShsbmcsIG5zLCBrZXksIHZhbHVlLCBvcHRpb25zID0ge1xuICAgIHNpbGVudDogZmFsc2VcbiAgfSkge1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgbGV0IHBhdGggPSBbbG5nLCBuc107XG4gICAgaWYgKGtleSkgcGF0aCA9IHBhdGguY29uY2F0KGtleVNlcGFyYXRvciA/IGtleS5zcGxpdChrZXlTZXBhcmF0b3IpIDoga2V5KTtcbiAgICBpZiAobG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBwYXRoID0gbG5nLnNwbGl0KCcuJyk7XG4gICAgICB2YWx1ZSA9IG5zO1xuICAgICAgbnMgPSBwYXRoWzFdO1xuICAgIH1cbiAgICB0aGlzLmFkZE5hbWVzcGFjZXMobnMpO1xuICAgIHNldFBhdGgodGhpcy5kYXRhLCBwYXRoLCB2YWx1ZSk7XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy5lbWl0KCdhZGRlZCcsIGxuZywgbnMsIGtleSwgdmFsdWUpO1xuICB9XG4gIGFkZFJlc291cmNlcyhsbmcsIG5zLCByZXNvdXJjZXMsIG9wdGlvbnMgPSB7XG4gICAgc2lsZW50OiBmYWxzZVxuICB9KSB7XG4gICAgZm9yIChjb25zdCBtIGluIHJlc291cmNlcykge1xuICAgICAgaWYgKGlzU3RyaW5nKHJlc291cmNlc1ttXSkgfHwgQXJyYXkuaXNBcnJheShyZXNvdXJjZXNbbV0pKSB0aGlzLmFkZFJlc291cmNlKGxuZywgbnMsIG0sIHJlc291cmNlc1ttXSwge1xuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywgcmVzb3VyY2VzKTtcbiAgfVxuICBhZGRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zLCByZXNvdXJjZXMsIGRlZXAsIG92ZXJ3cml0ZSwgb3B0aW9ucyA9IHtcbiAgICBzaWxlbnQ6IGZhbHNlLFxuICAgIHNraXBDb3B5OiBmYWxzZVxuICB9KSB7XG4gICAgbGV0IHBhdGggPSBbbG5nLCBuc107XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgICAgZGVlcCA9IHJlc291cmNlcztcbiAgICAgIHJlc291cmNlcyA9IG5zO1xuICAgICAgbnMgPSBwYXRoWzFdO1xuICAgIH1cbiAgICB0aGlzLmFkZE5hbWVzcGFjZXMobnMpO1xuICAgIGxldCBwYWNrID0gZ2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgpIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5za2lwQ29weSkgcmVzb3VyY2VzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXNvdXJjZXMpKTtcbiAgICBpZiAoZGVlcCkge1xuICAgICAgZGVlcEV4dGVuZChwYWNrLCByZXNvdXJjZXMsIG92ZXJ3cml0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2sgPSB7XG4gICAgICAgIC4uLnBhY2ssXG4gICAgICAgIC4uLnJlc291cmNlc1xuICAgICAgfTtcbiAgICB9XG4gICAgc2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgsIHBhY2spO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCByZXNvdXJjZXMpO1xuICB9XG4gIHJlbW92ZVJlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkge1xuICAgICAgZGVsZXRlIHRoaXMuZGF0YVtsbmddW25zXTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVOYW1lc3BhY2VzKG5zKTtcbiAgICB0aGlzLmVtaXQoJ3JlbW92ZWQnLCBsbmcsIG5zKTtcbiAgfVxuICBoYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucykgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgaWYgKCFucykgbnMgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdE5TO1xuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpO1xuICB9XG4gIGdldERhdGFCeUxhbmd1YWdlKGxuZykge1xuICAgIHJldHVybiB0aGlzLmRhdGFbbG5nXTtcbiAgfVxuICBoYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMobG5nKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YUJ5TGFuZ3VhZ2UobG5nKTtcbiAgICBjb25zdCBuID0gZGF0YSAmJiBPYmplY3Qua2V5cyhkYXRhKSB8fCBbXTtcbiAgICByZXR1cm4gISFuLmZpbmQodiA9PiBkYXRhW3ZdICYmIE9iamVjdC5rZXlzKGRhdGFbdl0pLmxlbmd0aCA+IDApO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG59XG5cbnZhciBwb3N0UHJvY2Vzc29yID0ge1xuICBwcm9jZXNzb3JzOiB7fSxcbiAgYWRkUG9zdFByb2Nlc3Nvcihtb2R1bGUpIHtcbiAgICB0aGlzLnByb2Nlc3NvcnNbbW9kdWxlLm5hbWVdID0gbW9kdWxlO1xuICB9LFxuICBoYW5kbGUocHJvY2Vzc29ycywgdmFsdWUsIGtleSwgb3B0aW9ucywgdHJhbnNsYXRvcikge1xuICAgIHByb2Nlc3NvcnMuZm9yRWFjaChwcm9jZXNzb3IgPT4ge1xuICAgICAgdmFsdWUgPSB0aGlzLnByb2Nlc3NvcnNbcHJvY2Vzc29yXT8ucHJvY2Vzcyh2YWx1ZSwga2V5LCBvcHRpb25zLCB0cmFuc2xhdG9yKSA/PyB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbmNvbnN0IFBBVEhfS0VZID0gU3ltYm9sKCdpMThuZXh0L1BBVEhfS0VZJyk7XG5mdW5jdGlvbiBjcmVhdGVQcm94eSgpIHtcbiAgY29uc3Qgc3RhdGUgPSBbXTtcbiAgY29uc3QgaGFuZGxlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBwcm94eTtcbiAgaGFuZGxlci5nZXQgPSAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICBwcm94eT8ucmV2b2tlPy4oKTtcbiAgICBpZiAoa2V5ID09PSBQQVRIX0tFWSkgcmV0dXJuIHN0YXRlO1xuICAgIHN0YXRlLnB1c2goa2V5KTtcbiAgICBwcm94eSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIGhhbmRsZXIpO1xuICAgIHJldHVybiBwcm94eS5wcm94eTtcbiAgfTtcbiAgcmV0dXJuIFByb3h5LnJldm9jYWJsZShPYmplY3QuY3JlYXRlKG51bGwpLCBoYW5kbGVyKS5wcm94eTtcbn1cbmZ1bmN0aW9uIGtleXNGcm9tU2VsZWN0b3Ioc2VsZWN0b3IsIG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIFtQQVRIX0tFWV06IHBhdGhcbiAgfSA9IHNlbGVjdG9yKGNyZWF0ZVByb3h5KCkpO1xuICByZXR1cm4gcGF0aC5qb2luKG9wdHM/LmtleVNlcGFyYXRvciA/PyAnLicpO1xufVxuXG5jb25zdCBjaGVja2VkTG9hZGVkRm9yID0ge307XG5jb25zdCBzaG91bGRIYW5kbGVBc09iamVjdCA9IHJlcyA9PiAhaXNTdHJpbmcocmVzKSAmJiB0eXBlb2YgcmVzICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIHJlcyAhPT0gJ251bWJlcic7XG5jbGFzcyBUcmFuc2xhdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioc2VydmljZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29weShbJ3Jlc291cmNlU3RvcmUnLCAnbGFuZ3VhZ2VVdGlscycsICdwbHVyYWxSZXNvbHZlcicsICdpbnRlcnBvbGF0b3InLCAnYmFja2VuZENvbm5lY3RvcicsICdpMThuRm9ybWF0JywgJ3V0aWxzJ10sIHNlcnZpY2VzLCB0aGlzKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPSAnLic7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ3RyYW5zbGF0b3InKTtcbiAgfVxuICBjaGFuZ2VMYW5ndWFnZShsbmcpIHtcbiAgICBpZiAobG5nKSB0aGlzLmxhbmd1YWdlID0gbG5nO1xuICB9XG4gIGV4aXN0cyhrZXksIG8gPSB7XG4gICAgaW50ZXJwb2xhdGlvbjoge31cbiAgfSkge1xuICAgIGNvbnN0IG9wdCA9IHtcbiAgICAgIC4uLm9cbiAgICB9O1xuICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlKGtleSwgb3B0KTtcbiAgICBpZiAocmVzb2x2ZWQ/LnJlcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaXNPYmplY3QgPSBzaG91bGRIYW5kbGVBc09iamVjdChyZXNvbHZlZC5yZXMpO1xuICAgIGlmIChvcHQucmV0dXJuT2JqZWN0cyA9PT0gZmFsc2UgJiYgaXNPYmplY3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZXh0cmFjdEZyb21LZXkoa2V5LCBvcHQpIHtcbiAgICBsZXQgbnNTZXBhcmF0b3IgPSBvcHQubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdC5uc1NlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5uc1NlcGFyYXRvcjtcbiAgICBpZiAobnNTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgbnNTZXBhcmF0b3IgPSAnOic7XG4gICAgY29uc3Qga2V5U2VwYXJhdG9yID0gb3B0LmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0LmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgbGV0IG5hbWVzcGFjZXMgPSBvcHQubnMgfHwgdGhpcy5vcHRpb25zLmRlZmF1bHROUyB8fCBbXTtcbiAgICBjb25zdCB3b3VsZENoZWNrRm9yTnNJbktleSA9IG5zU2VwYXJhdG9yICYmIGtleS5pbmRleE9mKG5zU2VwYXJhdG9yKSA+IC0xO1xuICAgIGNvbnN0IHNlZW1zTmF0dXJhbExhbmd1YWdlID0gIXRoaXMub3B0aW9ucy51c2VyRGVmaW5lZEtleVNlcGFyYXRvciAmJiAhb3B0LmtleVNlcGFyYXRvciAmJiAhdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkTnNTZXBhcmF0b3IgJiYgIW9wdC5uc1NlcGFyYXRvciAmJiAhbG9va3NMaWtlT2JqZWN0UGF0aChrZXksIG5zU2VwYXJhdG9yLCBrZXlTZXBhcmF0b3IpO1xuICAgIGlmICh3b3VsZENoZWNrRm9yTnNJbktleSAmJiAhc2VlbXNOYXR1cmFsTGFuZ3VhZ2UpIHtcbiAgICAgIGNvbnN0IG0gPSBrZXkubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICBpZiAobSAmJiBtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmFtZXNwYWNlczogaXNTdHJpbmcobmFtZXNwYWNlcykgPyBbbmFtZXNwYWNlc10gOiBuYW1lc3BhY2VzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdChuc1NlcGFyYXRvcik7XG4gICAgICBpZiAobnNTZXBhcmF0b3IgIT09IGtleVNlcGFyYXRvciB8fCBuc1NlcGFyYXRvciA9PT0ga2V5U2VwYXJhdG9yICYmIHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKHBhcnRzWzBdKSA+IC0xKSBuYW1lc3BhY2VzID0gcGFydHMuc2hpZnQoKTtcbiAgICAgIGtleSA9IHBhcnRzLmpvaW4oa2V5U2VwYXJhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZXM6IGlzU3RyaW5nKG5hbWVzcGFjZXMpID8gW25hbWVzcGFjZXNdIDogbmFtZXNwYWNlc1xuICAgIH07XG4gIH1cbiAgdHJhbnNsYXRlKGtleXMsIG8sIGxhc3RLZXkpIHtcbiAgICBsZXQgb3B0ID0gdHlwZW9mIG8gPT09ICdvYmplY3QnID8ge1xuICAgICAgLi4ub1xuICAgIH0gOiBvO1xuICAgIGlmICh0eXBlb2Ygb3B0ICE9PSAnb2JqZWN0JyAmJiB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIpIHtcbiAgICAgIG9wdCA9IHRoaXMub3B0aW9ucy5vdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcihhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ29iamVjdCcpIG9wdCA9IHtcbiAgICAgIC4uLm9wdFxuICAgIH07XG4gICAgaWYgKCFvcHQpIG9wdCA9IHt9O1xuICAgIGlmIChrZXlzID09IG51bGwpIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGtleXMgPT09ICdmdW5jdGlvbicpIGtleXMgPSBrZXlzRnJvbVNlbGVjdG9yKGtleXMsIHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdFxuICAgIH0pO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkga2V5cyA9IFtTdHJpbmcoa2V5cyldO1xuICAgIGNvbnN0IHJldHVybkRldGFpbHMgPSBvcHQucmV0dXJuRGV0YWlscyAhPT0gdW5kZWZpbmVkID8gb3B0LnJldHVybkRldGFpbHMgOiB0aGlzLm9wdGlvbnMucmV0dXJuRGV0YWlscztcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHQua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHQua2V5U2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICBjb25zdCB7XG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VzXG4gICAgfSA9IHRoaXMuZXh0cmFjdEZyb21LZXkoa2V5c1trZXlzLmxlbmd0aCAtIDFdLCBvcHQpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgbnNTZXBhcmF0b3IgPSBvcHQubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdC5uc1NlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5uc1NlcGFyYXRvcjtcbiAgICBpZiAobnNTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgbnNTZXBhcmF0b3IgPSAnOic7XG4gICAgY29uc3QgbG5nID0gb3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlO1xuICAgIGNvbnN0IGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlID0gb3B0LmFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIHx8IHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb0NJTW9kZTtcbiAgICBpZiAobG5nPy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJykge1xuICAgICAgaWYgKGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlKSB7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlczogYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YCxcbiAgICAgICAgICAgIHVzZWRLZXk6IGtleSxcbiAgICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgICAgdXNlZE5TOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtuYW1lc3BhY2V9JHtuc1NlcGFyYXRvcn0ke2tleX1gO1xuICAgICAgfVxuICAgICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXM6IGtleSxcbiAgICAgICAgICB1c2VkS2V5OiBrZXksXG4gICAgICAgICAgZXhhY3RVc2VkS2V5OiBrZXksXG4gICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgIHVzZWROUzogbmFtZXNwYWNlLFxuICAgICAgICAgIHVzZWRQYXJhbXM6IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmUoa2V5cywgb3B0KTtcbiAgICBsZXQgcmVzID0gcmVzb2x2ZWQ/LnJlcztcbiAgICBjb25zdCByZXNVc2VkS2V5ID0gcmVzb2x2ZWQ/LnVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IHJlc0V4YWN0VXNlZEtleSA9IHJlc29sdmVkPy5leGFjdFVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IG5vT2JqZWN0ID0gWydbb2JqZWN0IE51bWJlcl0nLCAnW29iamVjdCBGdW5jdGlvbl0nLCAnW29iamVjdCBSZWdFeHBdJ107XG4gICAgY29uc3Qgam9pbkFycmF5cyA9IG9wdC5qb2luQXJyYXlzICE9PSB1bmRlZmluZWQgPyBvcHQuam9pbkFycmF5cyA6IHRoaXMub3B0aW9ucy5qb2luQXJyYXlzO1xuICAgIGNvbnN0IGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ID0gIXRoaXMuaTE4bkZvcm1hdCB8fCB0aGlzLmkxOG5Gb3JtYXQuaGFuZGxlQXNPYmplY3Q7XG4gICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdC5jb3VudCAhPT0gdW5kZWZpbmVkICYmICFpc1N0cmluZyhvcHQuY291bnQpO1xuICAgIGNvbnN0IGhhc0RlZmF1bHRWYWx1ZSA9IFRyYW5zbGF0b3IuaGFzRGVmYXVsdFZhbHVlKG9wdCk7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4ID0gbmVlZHNQbHVyYWxIYW5kbGluZyA/IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGxuZywgb3B0LmNvdW50LCBvcHQpIDogJyc7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrID0gb3B0Lm9yZGluYWwgJiYgbmVlZHNQbHVyYWxIYW5kbGluZyA/IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGxuZywgb3B0LmNvdW50LCB7XG4gICAgICBvcmRpbmFsOiBmYWxzZVxuICAgIH0pIDogJyc7XG4gICAgY29uc3QgbmVlZHNaZXJvU3VmZml4TG9va3VwID0gbmVlZHNQbHVyYWxIYW5kbGluZyAmJiAhb3B0Lm9yZGluYWwgJiYgb3B0LmNvdW50ID09PSAwO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCAmJiBvcHRbYGRlZmF1bHRWYWx1ZSR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYF0gfHwgb3B0W2BkZWZhdWx0VmFsdWUke2RlZmF1bHRWYWx1ZVN1ZmZpeH1gXSB8fCBvcHRbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrfWBdIHx8IG9wdC5kZWZhdWx0VmFsdWU7XG4gICAgbGV0IHJlc0Zvck9iakhuZGwgPSByZXM7XG4gICAgaWYgKGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ICYmICFyZXMgJiYgaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXNGb3JPYmpIbmRsID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVBc09iamVjdCA9IHNob3VsZEhhbmRsZUFzT2JqZWN0KHJlc0Zvck9iakhuZGwpO1xuICAgIGNvbnN0IHJlc1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlc0Zvck9iakhuZGwpO1xuICAgIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiByZXNGb3JPYmpIbmRsICYmIGhhbmRsZUFzT2JqZWN0ICYmIG5vT2JqZWN0LmluZGV4T2YocmVzVHlwZSkgPCAwICYmICEoaXNTdHJpbmcoam9pbkFycmF5cykgJiYgQXJyYXkuaXNBcnJheShyZXNGb3JPYmpIbmRsKSkpIHtcbiAgICAgIGlmICghb3B0LnJldHVybk9iamVjdHMgJiYgIXRoaXMub3B0aW9ucy5yZXR1cm5PYmplY3RzKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2FjY2Vzc2luZyBhbiBvYmplY3QgLSBidXQgcmV0dXJuT2JqZWN0cyBvcHRpb25zIGlzIG5vdCBlbmFibGVkIScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyID8gdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcihyZXNVc2VkS2V5LCByZXNGb3JPYmpIbmRsLCB7XG4gICAgICAgICAgLi4ub3B0LFxuICAgICAgICAgIG5zOiBuYW1lc3BhY2VzXG4gICAgICAgIH0pIDogYGtleSAnJHtrZXl9ICgke3RoaXMubGFuZ3VhZ2V9KScgcmV0dXJuZWQgYW4gb2JqZWN0IGluc3RlYWQgb2Ygc3RyaW5nLmA7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmVzb2x2ZWQucmVzID0gcjtcbiAgICAgICAgICByZXNvbHZlZC51c2VkUGFyYW1zID0gdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVzVHlwZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHJlc0Zvck9iakhuZGwpO1xuICAgICAgICBjb25zdCBjb3B5ID0gcmVzVHlwZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICBjb25zdCBuZXdLZXlUb1VzZSA9IHJlc1R5cGVJc0FycmF5ID8gcmVzRXhhY3RVc2VkS2V5IDogcmVzVXNlZEtleTtcbiAgICAgICAgZm9yIChjb25zdCBtIGluIHJlc0Zvck9iakhuZGwpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc0Zvck9iakhuZGwsIG0pKSB7XG4gICAgICAgICAgICBjb25zdCBkZWVwS2V5ID0gYCR7bmV3S2V5VG9Vc2V9JHtrZXlTZXBhcmF0b3J9JHttfWA7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdFZhbHVlICYmICFyZXMpIHtcbiAgICAgICAgICAgICAgY29weVttXSA9IHRoaXMudHJhbnNsYXRlKGRlZXBLZXksIHtcbiAgICAgICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzaG91bGRIYW5kbGVBc09iamVjdChkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlW21dIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgIGpvaW5BcnJheXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29weVttXSA9IHRoaXMudHJhbnNsYXRlKGRlZXBLZXksIHtcbiAgICAgICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICAgICAgLi4ue1xuICAgICAgICAgICAgICAgICAgam9pbkFycmF5czogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBuczogbmFtZXNwYWNlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29weVttXSA9PT0gZGVlcEtleSkgY29weVttXSA9IHJlc0Zvck9iakhuZGxbbV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGNvcHk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiBpc1N0cmluZyhqb2luQXJyYXlzKSAmJiBBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgIHJlcyA9IHJlcy5qb2luKGpvaW5BcnJheXMpO1xuICAgICAgaWYgKHJlcykgcmVzID0gdGhpcy5leHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleXMsIG9wdCwgbGFzdEtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB1c2VkRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgbGV0IHVzZWRLZXkgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKHJlcykgJiYgaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHVzZWREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgcmVzID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAocmVzKSkge1xuICAgICAgICB1c2VkS2V5ID0gdHJ1ZTtcbiAgICAgICAgcmVzID0ga2V5O1xuICAgICAgfVxuICAgICAgY29uc3QgbWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5ID0gb3B0Lm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5O1xuICAgICAgY29uc3QgcmVzRm9yTWlzc2luZyA9IG1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSAmJiB1c2VkS2V5ID8gdW5kZWZpbmVkIDogcmVzO1xuICAgICAgY29uc3QgdXBkYXRlTWlzc2luZyA9IGhhc0RlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUgIT09IHJlcyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlTWlzc2luZztcbiAgICAgIGlmICh1c2VkS2V5IHx8IHVzZWREZWZhdWx0IHx8IHVwZGF0ZU1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKHVwZGF0ZU1pc3NpbmcgPyAndXBkYXRlS2V5JyA6ICdtaXNzaW5nS2V5JywgbG5nLCBuYW1lc3BhY2UsIGtleSwgdXBkYXRlTWlzc2luZyA/IGRlZmF1bHRWYWx1ZSA6IHJlcyk7XG4gICAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBjb25zdCBmayA9IHRoaXMucmVzb2x2ZShrZXksIHtcbiAgICAgICAgICAgIC4uLm9wdCxcbiAgICAgICAgICAgIGtleVNlcGFyYXRvcjogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZmsgJiYgZmsucmVzKSB0aGlzLmxvZ2dlci53YXJuKCdTZWVtcyB0aGUgbG9hZGVkIHRyYW5zbGF0aW9ucyB3ZXJlIGluIGZsYXQgSlNPTiBmb3JtYXQgaW5zdGVhZCBvZiBuZXN0ZWQuIEVpdGhlciBzZXQga2V5U2VwYXJhdG9yOiBmYWxzZSBvbiBpbml0IG9yIG1ha2Ugc3VyZSB5b3VyIHRyYW5zbGF0aW9ucyBhcmUgcHVibGlzaGVkIGluIG5lc3RlZCBmb3JtYXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxuZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tMbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nLCBvcHQubG5nIHx8IHRoaXMubGFuZ3VhZ2UpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nVG8gPT09ICdmYWxsYmFjaycgJiYgZmFsbGJhY2tMbmdzICYmIGZhbGxiYWNrTG5nc1swXSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFsbGJhY2tMbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsbmdzLnB1c2goZmFsbGJhY2tMbmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nVG8gPT09ICdhbGwnKSB7XG4gICAgICAgICAgbG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsbmdzLnB1c2gob3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kID0gKGwsIGssIHNwZWNpZmljRGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdEZvck1pc3NpbmcgPSBoYXNEZWZhdWx0VmFsdWUgJiYgc3BlY2lmaWNEZWZhdWx0VmFsdWUgIT09IHJlcyA/IHNwZWNpZmljRGVmYXVsdFZhbHVlIDogcmVzRm9yTWlzc2luZztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pc3NpbmdLZXlIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWlzc2luZ0tleUhhbmRsZXIobCwgbmFtZXNwYWNlLCBrLCBkZWZhdWx0Rm9yTWlzc2luZywgdXBkYXRlTWlzc2luZywgb3B0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYmFja2VuZENvbm5lY3Rvcj8uc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2VuZENvbm5lY3Rvci5zYXZlTWlzc2luZyhsLCBuYW1lc3BhY2UsIGssIGRlZmF1bHRGb3JNaXNzaW5nLCB1cGRhdGVNaXNzaW5nLCBvcHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ21pc3NpbmdLZXknLCBsLCBuYW1lc3BhY2UsIGssIHJlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nUGx1cmFscyAmJiBuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICBsbmdzLmZvckVhY2gobGFuZ3VhZ2UgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzdWZmaXhlcyA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4ZXMobGFuZ3VhZ2UsIG9wdCk7XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXAgJiYgb3B0W2BkZWZhdWx0VmFsdWUke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2BdICYmIHN1ZmZpeGVzLmluZGV4T2YoYCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3VmZml4ZXMucHVzaChgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdWZmaXhlcy5mb3JFYWNoKHN1ZmZpeCA9PiB7XG4gICAgICAgICAgICAgICAgc2VuZChbbGFuZ3VhZ2VdLCBrZXkgKyBzdWZmaXgsIG9wdFtgZGVmYXVsdFZhbHVlJHtzdWZmaXh9YF0gfHwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZChsbmdzLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMgPSB0aGlzLmV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5cywgb3B0LCByZXNvbHZlZCwgbGFzdEtleSk7XG4gICAgICBpZiAodXNlZEtleSAmJiByZXMgPT09IGtleSAmJiB0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5KSB7XG4gICAgICAgIHJlcyA9IGAke25hbWVzcGFjZX0ke25zU2VwYXJhdG9yfSR7a2V5fWA7XG4gICAgICB9XG4gICAgICBpZiAoKHVzZWRLZXkgfHwgdXNlZERlZmF1bHQpICYmIHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKSB7XG4gICAgICAgIHJlcyA9IHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkgPyBgJHtuYW1lc3BhY2V9JHtuc1NlcGFyYXRvcn0ke2tleX1gIDoga2V5LCB1c2VkRGVmYXVsdCA/IHJlcyA6IHVuZGVmaW5lZCwgb3B0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgIHJlc29sdmVkLnJlcyA9IHJlcztcbiAgICAgIHJlc29sdmVkLnVzZWRQYXJhbXMgPSB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdCk7XG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXksIG9wdCwgcmVzb2x2ZWQsIGxhc3RLZXkpIHtcbiAgICBpZiAodGhpcy5pMThuRm9ybWF0Py5wYXJzZSkge1xuICAgICAgcmVzID0gdGhpcy5pMThuRm9ybWF0LnBhcnNlKHJlcywge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzLFxuICAgICAgICAuLi5vcHRcbiAgICAgIH0sIG9wdC5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCByZXNvbHZlZC51c2VkTlMsIHJlc29sdmVkLnVzZWRLZXksIHtcbiAgICAgICAgcmVzb2x2ZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW9wdC5za2lwSW50ZXJwb2xhdGlvbikge1xuICAgICAgaWYgKG9wdC5pbnRlcnBvbGF0aW9uKSB0aGlzLmludGVycG9sYXRvci5pbml0KHtcbiAgICAgICAgLi4ub3B0LFxuICAgICAgICAuLi57XG4gICAgICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICAuLi5vcHQuaW50ZXJwb2xhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBza2lwT25WYXJpYWJsZXMgPSBpc1N0cmluZyhyZXMpICYmIChvcHQ/LmludGVycG9sYXRpb24/LnNraXBPblZhcmlhYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0LmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzIDogdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzKTtcbiAgICAgIGxldCBuZXN0QmVmO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYiA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgbmVzdEJlZiA9IG5iICYmIG5iLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxldCBkYXRhID0gb3B0LnJlcGxhY2UgJiYgIWlzU3RyaW5nKG9wdC5yZXBsYWNlKSA/IG9wdC5yZXBsYWNlIDogb3B0O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgICByZXMgPSB0aGlzLmludGVycG9sYXRvci5pbnRlcnBvbGF0ZShyZXMsIGRhdGEsIG9wdC5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCBvcHQpO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYSA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgY29uc3QgbmVzdEFmdCA9IG5hICYmIG5hLmxlbmd0aDtcbiAgICAgICAgaWYgKG5lc3RCZWYgPCBuZXN0QWZ0KSBvcHQubmVzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHQubG5nICYmIHJlc29sdmVkICYmIHJlc29sdmVkLnJlcykgb3B0LmxuZyA9IHRoaXMubGFuZ3VhZ2UgfHwgcmVzb2x2ZWQudXNlZExuZztcbiAgICAgIGlmIChvcHQubmVzdCAhPT0gZmFsc2UpIHJlcyA9IHRoaXMuaW50ZXJwb2xhdG9yLm5lc3QocmVzLCAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAobGFzdEtleT8uWzBdID09PSBhcmdzWzBdICYmICFvcHQuY29udGV4dCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYEl0IHNlZW1zIHlvdSBhcmUgbmVzdGluZyByZWN1cnNpdmVseSBrZXk6ICR7YXJnc1swXX0gaW4ga2V5OiAke2tleVswXX1gKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoLi4uYXJncywga2V5KTtcbiAgICAgIH0sIG9wdCk7XG4gICAgICBpZiAob3B0LmludGVycG9sYXRpb24pIHRoaXMuaW50ZXJwb2xhdG9yLnJlc2V0KCk7XG4gICAgfVxuICAgIGNvbnN0IHBvc3RQcm9jZXNzID0gb3B0LnBvc3RQcm9jZXNzIHx8IHRoaXMub3B0aW9ucy5wb3N0UHJvY2VzcztcbiAgICBjb25zdCBwb3N0UHJvY2Vzc29yTmFtZXMgPSBpc1N0cmluZyhwb3N0UHJvY2VzcykgPyBbcG9zdFByb2Nlc3NdIDogcG9zdFByb2Nlc3M7XG4gICAgaWYgKHJlcyAhPSBudWxsICYmIHBvc3RQcm9jZXNzb3JOYW1lcz8ubGVuZ3RoICYmIG9wdC5hcHBseVBvc3RQcm9jZXNzb3IgIT09IGZhbHNlKSB7XG4gICAgICByZXMgPSBwb3N0UHJvY2Vzc29yLmhhbmRsZShwb3N0UHJvY2Vzc29yTmFtZXMsIHJlcywga2V5LCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkID8ge1xuICAgICAgICBpMThuUmVzb2x2ZWQ6IHtcbiAgICAgICAgICAuLi5yZXNvbHZlZCxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdClcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0XG4gICAgICB9IDogb3B0LCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXNvbHZlKGtleXMsIG9wdCA9IHt9KSB7XG4gICAgbGV0IGZvdW5kO1xuICAgIGxldCB1c2VkS2V5O1xuICAgIGxldCBleGFjdFVzZWRLZXk7XG4gICAgbGV0IHVzZWRMbmc7XG4gICAgbGV0IHVzZWROUztcbiAgICBpZiAoaXNTdHJpbmcoa2V5cykpIGtleXMgPSBba2V5c107XG4gICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHRoaXMuZXh0cmFjdEZyb21LZXkoaywgb3B0KTtcbiAgICAgIGNvbnN0IGtleSA9IGV4dHJhY3RlZC5rZXk7XG4gICAgICB1c2VkS2V5ID0ga2V5O1xuICAgICAgbGV0IG5hbWVzcGFjZXMgPSBleHRyYWN0ZWQubmFtZXNwYWNlcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmFsbGJhY2tOUykgbmFtZXNwYWNlcyA9IG5hbWVzcGFjZXMuY29uY2F0KHRoaXMub3B0aW9ucy5mYWxsYmFja05TKTtcbiAgICAgIGNvbnN0IG5lZWRzUGx1cmFsSGFuZGxpbmcgPSBvcHQuY291bnQgIT09IHVuZGVmaW5lZCAmJiAhaXNTdHJpbmcob3B0LmNvdW50KTtcbiAgICAgIGNvbnN0IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCA9IG5lZWRzUGx1cmFsSGFuZGxpbmcgJiYgIW9wdC5vcmRpbmFsICYmIG9wdC5jb3VudCA9PT0gMDtcbiAgICAgIGNvbnN0IG5lZWRzQ29udGV4dEhhbmRsaW5nID0gb3B0LmNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiAoaXNTdHJpbmcob3B0LmNvbnRleHQpIHx8IHR5cGVvZiBvcHQuY29udGV4dCA9PT0gJ251bWJlcicpICYmIG9wdC5jb250ZXh0ICE9PSAnJztcbiAgICAgIGNvbnN0IGNvZGVzID0gb3B0LmxuZ3MgPyBvcHQubG5ncyA6IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlLCBvcHQuZmFsbGJhY2tMbmcpO1xuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKG5zID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgICAgdXNlZE5TID0gbnM7XG4gICAgICAgIGlmICghY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSAmJiB0aGlzLnV0aWxzPy5oYXNMb2FkZWROYW1lc3BhY2UgJiYgIXRoaXMudXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZSh1c2VkTlMpKSB7XG4gICAgICAgICAgY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2Fybihga2V5IFwiJHt1c2VkS2V5fVwiIGZvciBsYW5ndWFnZXMgXCIke2NvZGVzLmpvaW4oJywgJyl9XCIgd29uJ3QgZ2V0IHJlc29sdmVkIGFzIG5hbWVzcGFjZSBcIiR7dXNlZE5TfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICAgICAgdXNlZExuZyA9IGNvZGU7XG4gICAgICAgICAgY29uc3QgZmluYWxLZXlzID0gW2tleV07XG4gICAgICAgICAgaWYgKHRoaXMuaTE4bkZvcm1hdD8uYWRkTG9va3VwS2V5cykge1xuICAgICAgICAgICAgdGhpcy5pMThuRm9ybWF0LmFkZExvb2t1cEtleXMoZmluYWxLZXlzLCBrZXksIGNvZGUsIG5zLCBvcHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGx1cmFsU3VmZml4O1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHBsdXJhbFN1ZmZpeCA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGNvZGUsIG9wdC5jb3VudCwgb3B0KTtcbiAgICAgICAgICAgIGNvbnN0IHplcm9TdWZmaXggPSBgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gO1xuICAgICAgICAgICAgY29uc3Qgb3JkaW5hbFByZWZpeCA9IGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9b3JkaW5hbCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn1gO1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdC5vcmRpbmFsICYmIHBsdXJhbFN1ZmZpeC5pbmRleE9mKG9yZGluYWxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4LnJlcGxhY2Uob3JkaW5hbFByZWZpeCwgdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGtleSArIHBsdXJhbFN1ZmZpeCk7XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXApIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyB6ZXJvU3VmZml4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRzQ29udGV4dEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSBgJHtrZXl9JHt0aGlzLm9wdGlvbnMuY29udGV4dFNlcGFyYXRvciB8fCAnXyd9JHtvcHQuY29udGV4dH1gO1xuICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5KTtcbiAgICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lm9yZGluYWwgJiYgcGx1cmFsU3VmZml4LmluZGV4T2Yob3JkaW5hbFByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyBwbHVyYWxTdWZmaXgucmVwbGFjZShvcmRpbmFsUHJlZml4LCB0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyBwbHVyYWxTdWZmaXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXApIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyB6ZXJvU3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHBvc3NpYmxlS2V5O1xuICAgICAgICAgIHdoaWxlIChwb3NzaWJsZUtleSA9IGZpbmFsS2V5cy5wb3AoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSB7XG4gICAgICAgICAgICAgIGV4YWN0VXNlZEtleSA9IHBvc3NpYmxlS2V5O1xuICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIHBvc3NpYmxlS2V5LCBvcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzOiBmb3VuZCxcbiAgICAgIHVzZWRLZXksXG4gICAgICBleGFjdFVzZWRLZXksXG4gICAgICB1c2VkTG5nLFxuICAgICAgdXNlZE5TXG4gICAgfTtcbiAgfVxuICBpc1ZhbGlkTG9va3VwKHJlcykge1xuICAgIHJldHVybiByZXMgIT09IHVuZGVmaW5lZCAmJiAhKCF0aGlzLm9wdGlvbnMucmV0dXJuTnVsbCAmJiByZXMgPT09IG51bGwpICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5FbXB0eVN0cmluZyAmJiByZXMgPT09ICcnKTtcbiAgfVxuICBnZXRSZXNvdXJjZShjb2RlLCBucywga2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5pMThuRm9ybWF0Py5nZXRSZXNvdXJjZSkgcmV0dXJuIHRoaXMuaTE4bkZvcm1hdC5nZXRSZXNvdXJjZShjb2RlLCBucywga2V5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5yZXNvdXJjZVN0b3JlLmdldFJlc291cmNlKGNvZGUsIG5zLCBrZXksIG9wdGlvbnMpO1xuICB9XG4gIGdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdGlvbnNLZXlzID0gWydkZWZhdWx0VmFsdWUnLCAnb3JkaW5hbCcsICdjb250ZXh0JywgJ3JlcGxhY2UnLCAnbG5nJywgJ2xuZ3MnLCAnZmFsbGJhY2tMbmcnLCAnbnMnLCAna2V5U2VwYXJhdG9yJywgJ25zU2VwYXJhdG9yJywgJ3JldHVybk9iamVjdHMnLCAncmV0dXJuRGV0YWlscycsICdqb2luQXJyYXlzJywgJ3Bvc3RQcm9jZXNzJywgJ2ludGVycG9sYXRpb24nXTtcbiAgICBjb25zdCB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPSBvcHRpb25zLnJlcGxhY2UgJiYgIWlzU3RyaW5nKG9wdGlvbnMucmVwbGFjZSk7XG4gICAgbGV0IGRhdGEgPSB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPyBvcHRpb25zLnJlcGxhY2UgOiBvcHRpb25zO1xuICAgIGlmICh1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgJiYgdHlwZW9mIG9wdGlvbnMuY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLmNvdW50ID0gb3B0aW9ucy5jb3VudDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghdXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb3B0aW9uc0tleXMpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgc3RhdGljIGhhc0RlZmF1bHRWYWx1ZShvcHRpb25zKSB7XG4gICAgY29uc3QgcHJlZml4ID0gJ2RlZmF1bHRWYWx1ZSc7XG4gICAgZm9yIChjb25zdCBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHRpb24pICYmIHByZWZpeCA9PT0gb3B0aW9uLnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSAmJiB1bmRlZmluZWQgIT09IG9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmNsYXNzIExhbmd1YWdlVXRpbCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3VwcG9ydGVkTG5ncyA9IHRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzIHx8IGZhbHNlO1xuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ2xhbmd1YWdlVXRpbHMnKTtcbiAgfVxuICBnZXRTY3JpcHRQYXJ0RnJvbUNvZGUoY29kZSkge1xuICAgIGNvZGUgPSBnZXRDbGVhbmVkQ29kZShjb2RlKTtcbiAgICBpZiAoIWNvZGUgfHwgY29kZS5pbmRleE9mKCctJykgPCAwKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBwID0gY29kZS5zcGxpdCgnLScpO1xuICAgIGlmIChwLmxlbmd0aCA9PT0gMikgcmV0dXJuIG51bGw7XG4gICAgcC5wb3AoKTtcbiAgICBpZiAocFtwLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKHAuam9pbignLScpKTtcbiAgfVxuICBnZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKSB7XG4gICAgY29kZSA9IGdldENsZWFuZWRDb2RlKGNvZGUpO1xuICAgIGlmICghY29kZSB8fCBjb2RlLmluZGV4T2YoJy0nKSA8IDApIHJldHVybiBjb2RlO1xuICAgIGNvbnN0IHAgPSBjb2RlLnNwbGl0KCctJyk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKHBbMF0pO1xuICB9XG4gIGZvcm1hdExhbmd1YWdlQ29kZShjb2RlKSB7XG4gICAgaWYgKGlzU3RyaW5nKGNvZGUpICYmIGNvZGUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGxldCBmb3JtYXR0ZWRDb2RlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9ybWF0dGVkQ29kZSA9IEludGwuZ2V0Q2Fub25pY2FsTG9jYWxlcyhjb2RlKVswXTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICBpZiAoZm9ybWF0dGVkQ29kZSAmJiB0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nKSB7XG4gICAgICAgIGZvcm1hdHRlZENvZGUgPSBmb3JtYXR0ZWRDb2RlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0dGVkQ29kZSkgcmV0dXJuIGZvcm1hdHRlZENvZGU7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvd2VyQ2FzZUxuZykge1xuICAgICAgICByZXR1cm4gY29kZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xlYW5Db2RlIHx8IHRoaXMub3B0aW9ucy5sb3dlckNhc2VMbmcgPyBjb2RlLnRvTG93ZXJDYXNlKCkgOiBjb2RlO1xuICB9XG4gIGlzU3VwcG9ydGVkQ29kZShjb2RlKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkID09PSAnbGFuZ3VhZ2VPbmx5JyB8fCB0aGlzLm9wdGlvbnMubm9uRXhwbGljaXRTdXBwb3J0ZWRMbmdzKSB7XG4gICAgICBjb2RlID0gdGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLnN1cHBvcnRlZExuZ3MgfHwgIXRoaXMuc3VwcG9ydGVkTG5ncy5sZW5ndGggfHwgdGhpcy5zdXBwb3J0ZWRMbmdzLmluZGV4T2YoY29kZSkgPiAtMTtcbiAgfVxuICBnZXRCZXN0TWF0Y2hGcm9tQ29kZXMoY29kZXMpIHtcbiAgICBpZiAoIWNvZGVzKSByZXR1cm4gbnVsbDtcbiAgICBsZXQgZm91bmQ7XG4gICAgY29kZXMuZm9yRWFjaChjb2RlID0+IHtcbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuO1xuICAgICAgY29uc3QgY2xlYW5lZExuZyA9IHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncyB8fCB0aGlzLmlzU3VwcG9ydGVkQ29kZShjbGVhbmVkTG5nKSkgZm91bmQgPSBjbGVhbmVkTG5nO1xuICAgIH0pO1xuICAgIGlmICghZm91bmQgJiYgdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MpIHtcbiAgICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICAgIGlmIChmb3VuZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBsbmdTY09ubHkgPSB0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGxuZ1NjT25seSkpIHJldHVybiBmb3VuZCA9IGxuZ1NjT25seTtcbiAgICAgICAgY29uc3QgbG5nT25seSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShsbmdPbmx5KSkgcmV0dXJuIGZvdW5kID0gbG5nT25seTtcbiAgICAgICAgZm91bmQgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncy5maW5kKHN1cHBvcnRlZExuZyA9PiB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZyA9PT0gbG5nT25seSkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nLmluZGV4T2YoJy0nKSA8IDAgJiYgbG5nT25seS5pbmRleE9mKCctJykgPCAwKSByZXR1cm47XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykgPiAwICYmIGxuZ09ubHkuaW5kZXhPZignLScpIDwgMCAmJiBzdXBwb3J0ZWRMbmcuc3Vic3RyaW5nKDAsIHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykpID09PSBsbmdPbmx5KSByZXR1cm4gc3VwcG9ydGVkTG5nO1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcuaW5kZXhPZihsbmdPbmx5KSA9PT0gMCAmJiBsbmdPbmx5Lmxlbmd0aCA+IDEpIHJldHVybiBzdXBwb3J0ZWRMbmc7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghZm91bmQpIGZvdW5kID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZylbMF07XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGdldEZhbGxiYWNrQ29kZXMoZmFsbGJhY2tzLCBjb2RlKSB7XG4gICAgaWYgKCFmYWxsYmFja3MpIHJldHVybiBbXTtcbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrcyA9PT0gJ2Z1bmN0aW9uJykgZmFsbGJhY2tzID0gZmFsbGJhY2tzKGNvZGUpO1xuICAgIGlmIChpc1N0cmluZyhmYWxsYmFja3MpKSBmYWxsYmFja3MgPSBbZmFsbGJhY2tzXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmYWxsYmFja3MpKSByZXR1cm4gZmFsbGJhY2tzO1xuICAgIGlmICghY29kZSkgcmV0dXJuIGZhbGxiYWNrcy5kZWZhdWx0IHx8IFtdO1xuICAgIGxldCBmb3VuZCA9IGZhbGxiYWNrc1tjb2RlXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzLmRlZmF1bHQ7XG4gICAgcmV0dXJuIGZvdW5kIHx8IFtdO1xuICB9XG4gIHRvUmVzb2x2ZUhpZXJhcmNoeShjb2RlLCBmYWxsYmFja0NvZGUpIHtcbiAgICBjb25zdCBmYWxsYmFja0NvZGVzID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKChmYWxsYmFja0NvZGUgPT09IGZhbHNlID8gW10gOiBmYWxsYmFja0NvZGUpIHx8IHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyB8fCBbXSwgY29kZSk7XG4gICAgY29uc3QgY29kZXMgPSBbXTtcbiAgICBjb25zdCBhZGRDb2RlID0gYyA9PiB7XG4gICAgICBpZiAoIWMpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShjKSkge1xuICAgICAgICBjb2Rlcy5wdXNoKGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcmVqZWN0aW5nIGxhbmd1YWdlIGNvZGUgbm90IGZvdW5kIGluIHN1cHBvcnRlZExuZ3M6ICR7Y31gKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc1N0cmluZyhjb2RlKSAmJiAoY29kZS5pbmRleE9mKCctJykgPiAtMSB8fCBjb2RlLmluZGV4T2YoJ18nKSA+IC0xKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnbGFuZ3VhZ2VPbmx5JykgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdsYW5ndWFnZU9ubHknICYmIHRoaXMub3B0aW9ucy5sb2FkICE9PSAnY3VycmVudE9ubHknKSBhZGRDb2RlKHRoaXMuZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2N1cnJlbnRPbmx5JykgYWRkQ29kZSh0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGNvZGUpKSB7XG4gICAgICBhZGRDb2RlKHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpKTtcbiAgICB9XG4gICAgZmFsbGJhY2tDb2Rlcy5mb3JFYWNoKGZjID0+IHtcbiAgICAgIGlmIChjb2Rlcy5pbmRleE9mKGZjKSA8IDApIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoZmMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29kZXM7XG4gIH1cbn1cblxuY29uc3Qgc3VmZml4ZXNPcmRlciA9IHtcbiAgemVybzogMCxcbiAgb25lOiAxLFxuICB0d286IDIsXG4gIGZldzogMyxcbiAgbWFueTogNCxcbiAgb3RoZXI6IDVcbn07XG5jb25zdCBkdW1teVJ1bGUgPSB7XG4gIHNlbGVjdDogY291bnQgPT4gY291bnQgPT09IDEgPyAnb25lJyA6ICdvdGhlcicsXG4gIHJlc29sdmVkT3B0aW9uczogKCkgPT4gKHtcbiAgICBwbHVyYWxDYXRlZ29yaWVzOiBbJ29uZScsICdvdGhlciddXG4gIH0pXG59O1xuY2xhc3MgUGx1cmFsUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvcihsYW5ndWFnZVV0aWxzLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBsYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgncGx1cmFsUmVzb2x2ZXInKTtcbiAgICB0aGlzLnBsdXJhbFJ1bGVzQ2FjaGUgPSB7fTtcbiAgfVxuICBhZGRSdWxlKGxuZywgb2JqKSB7XG4gICAgdGhpcy5ydWxlc1tsbmddID0gb2JqO1xuICB9XG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5wbHVyYWxSdWxlc0NhY2hlID0ge307XG4gIH1cbiAgZ2V0UnVsZShjb2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjbGVhbmVkQ29kZSA9IGdldENsZWFuZWRDb2RlKGNvZGUgPT09ICdkZXYnID8gJ2VuJyA6IGNvZGUpO1xuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLm9yZGluYWwgPyAnb3JkaW5hbCcgOiAnY2FyZGluYWwnO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY2xlYW5lZENvZGUsXG4gICAgICB0eXBlXG4gICAgfSk7XG4gICAgaWYgKGNhY2hlS2V5IGluIHRoaXMucGx1cmFsUnVsZXNDYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGx1cmFsUnVsZXNDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIGxldCBydWxlO1xuICAgIHRyeSB7XG4gICAgICBydWxlID0gbmV3IEludGwuUGx1cmFsUnVsZXMoY2xlYW5lZENvZGUsIHtcbiAgICAgICAgdHlwZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIUludGwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ05vIEludGwgc3VwcG9ydCwgcGxlYXNlIHVzZSBhbiBJbnRsIHBvbHlmaWxsIScpO1xuICAgICAgICByZXR1cm4gZHVtbXlSdWxlO1xuICAgICAgfVxuICAgICAgaWYgKCFjb2RlLm1hdGNoKC8tfF8vKSkgcmV0dXJuIGR1bW15UnVsZTtcbiAgICAgIGNvbnN0IGxuZ1BhcnQgPSB0aGlzLmxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICBydWxlID0gdGhpcy5nZXRSdWxlKGxuZ1BhcnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLnBsdXJhbFJ1bGVzQ2FjaGVbY2FjaGVLZXldID0gcnVsZTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICBuZWVkc1BsdXJhbChjb2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgcnVsZSA9IHRoaXMuZ2V0UnVsZShjb2RlLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJ1bGUgPSB0aGlzLmdldFJ1bGUoJ2RldicsIG9wdGlvbnMpO1xuICAgIHJldHVybiBydWxlPy5yZXNvbHZlZE9wdGlvbnMoKS5wbHVyYWxDYXRlZ29yaWVzLmxlbmd0aCA+IDE7XG4gIH1cbiAgZ2V0UGx1cmFsRm9ybXNPZktleShjb2RlLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldFN1ZmZpeGVzKGNvZGUsIG9wdGlvbnMpLm1hcChzdWZmaXggPT4gYCR7a2V5fSR7c3VmZml4fWApO1xuICB9XG4gIGdldFN1ZmZpeGVzKGNvZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcnVsZSA9IHRoaXMuZ2V0UnVsZSgnZGV2Jywgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHJ1bGUucmVzb2x2ZWRPcHRpb25zKCkucGx1cmFsQ2F0ZWdvcmllcy5zb3J0KChwbHVyYWxDYXRlZ29yeTEsIHBsdXJhbENhdGVnb3J5MikgPT4gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTFdIC0gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTJdKS5tYXAocGx1cmFsQ2F0ZWdvcnkgPT4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cGx1cmFsQ2F0ZWdvcnl9YCk7XG4gIH1cbiAgZ2V0U3VmZml4KGNvZGUsIGNvdW50LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cnVsZS5zZWxlY3QoY291bnQpfWA7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oYG5vIHBsdXJhbCBydWxlIGZvdW5kIGZvcjogJHtjb2RlfWApO1xuICAgIHJldHVybiB0aGlzLmdldFN1ZmZpeCgnZGV2JywgY291bnQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmNvbnN0IGRlZXBGaW5kV2l0aERlZmF1bHRzID0gKGRhdGEsIGRlZmF1bHREYXRhLCBrZXksIGtleVNlcGFyYXRvciA9ICcuJywgaWdub3JlSlNPTlN0cnVjdHVyZSA9IHRydWUpID0+IHtcbiAgbGV0IHBhdGggPSBnZXRQYXRoV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpO1xuICBpZiAoIXBhdGggJiYgaWdub3JlSlNPTlN0cnVjdHVyZSAmJiBpc1N0cmluZyhrZXkpKSB7XG4gICAgcGF0aCA9IGRlZXBGaW5kKGRhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSBwYXRoID0gZGVlcEZpbmQoZGVmYXVsdERhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5jb25zdCByZWdleFNhZmUgPSB2YWwgPT4gdmFsLnJlcGxhY2UoL1xcJC9nLCAnJCQkJCcpO1xuY2xhc3MgSW50ZXJwb2xhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnaW50ZXJwb2xhdG9yJyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnM/LmludGVycG9sYXRpb24/LmZvcm1hdCB8fCAodmFsdWUgPT4gdmFsdWUpO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghb3B0aW9ucy5pbnRlcnBvbGF0aW9uKSBvcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgICBlc2NhcGVWYWx1ZTogdHJ1ZVxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgZXNjYXBlOiBlc2NhcGUkMSxcbiAgICAgIGVzY2FwZVZhbHVlLFxuICAgICAgdXNlUmF3VmFsdWVUb0VzY2FwZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIHByZWZpeEVzY2FwZWQsXG4gICAgICBzdWZmaXgsXG4gICAgICBzdWZmaXhFc2NhcGVkLFxuICAgICAgZm9ybWF0U2VwYXJhdG9yLFxuICAgICAgdW5lc2NhcGVTdWZmaXgsXG4gICAgICB1bmVzY2FwZVByZWZpeCxcbiAgICAgIG5lc3RpbmdQcmVmaXgsXG4gICAgICBuZXN0aW5nUHJlZml4RXNjYXBlZCxcbiAgICAgIG5lc3RpbmdTdWZmaXgsXG4gICAgICBuZXN0aW5nU3VmZml4RXNjYXBlZCxcbiAgICAgIG5lc3RpbmdPcHRpb25zU2VwYXJhdG9yLFxuICAgICAgbWF4UmVwbGFjZXMsXG4gICAgICBhbHdheXNGb3JtYXRcbiAgICB9ID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMuZXNjYXBlID0gZXNjYXBlJDEgIT09IHVuZGVmaW5lZCA/IGVzY2FwZSQxIDogZXNjYXBlO1xuICAgIHRoaXMuZXNjYXBlVmFsdWUgPSBlc2NhcGVWYWx1ZSAhPT0gdW5kZWZpbmVkID8gZXNjYXBlVmFsdWUgOiB0cnVlO1xuICAgIHRoaXMudXNlUmF3VmFsdWVUb0VzY2FwZSA9IHVzZVJhd1ZhbHVlVG9Fc2NhcGUgIT09IHVuZGVmaW5lZCA/IHVzZVJhd1ZhbHVlVG9Fc2NhcGUgOiBmYWxzZTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeCA/IHJlZ2V4RXNjYXBlKHByZWZpeCkgOiBwcmVmaXhFc2NhcGVkIHx8ICd7eyc7XG4gICAgdGhpcy5zdWZmaXggPSBzdWZmaXggPyByZWdleEVzY2FwZShzdWZmaXgpIDogc3VmZml4RXNjYXBlZCB8fCAnfX0nO1xuICAgIHRoaXMuZm9ybWF0U2VwYXJhdG9yID0gZm9ybWF0U2VwYXJhdG9yIHx8ICcsJztcbiAgICB0aGlzLnVuZXNjYXBlUHJlZml4ID0gdW5lc2NhcGVTdWZmaXggPyAnJyA6IHVuZXNjYXBlUHJlZml4IHx8ICctJztcbiAgICB0aGlzLnVuZXNjYXBlU3VmZml4ID0gdGhpcy51bmVzY2FwZVByZWZpeCA/ICcnIDogdW5lc2NhcGVTdWZmaXggfHwgJyc7XG4gICAgdGhpcy5uZXN0aW5nUHJlZml4ID0gbmVzdGluZ1ByZWZpeCA/IHJlZ2V4RXNjYXBlKG5lc3RpbmdQcmVmaXgpIDogbmVzdGluZ1ByZWZpeEVzY2FwZWQgfHwgcmVnZXhFc2NhcGUoJyR0KCcpO1xuICAgIHRoaXMubmVzdGluZ1N1ZmZpeCA9IG5lc3RpbmdTdWZmaXggPyByZWdleEVzY2FwZShuZXN0aW5nU3VmZml4KSA6IG5lc3RpbmdTdWZmaXhFc2NhcGVkIHx8IHJlZ2V4RXNjYXBlKCcpJyk7XG4gICAgdGhpcy5uZXN0aW5nT3B0aW9uc1NlcGFyYXRvciA9IG5lc3RpbmdPcHRpb25zU2VwYXJhdG9yIHx8ICcsJztcbiAgICB0aGlzLm1heFJlcGxhY2VzID0gbWF4UmVwbGFjZXMgfHwgMTAwMDtcbiAgICB0aGlzLmFsd2F5c0Zvcm1hdCA9IGFsd2F5c0Zvcm1hdCAhPT0gdW5kZWZpbmVkID8gYWx3YXlzRm9ybWF0IDogZmFsc2U7XG4gICAgdGhpcy5yZXNldFJlZ0V4cCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHRoaXMuaW5pdCh0aGlzLm9wdGlvbnMpO1xuICB9XG4gIHJlc2V0UmVnRXhwKCkge1xuICAgIGNvbnN0IGdldE9yUmVzZXRSZWdFeHAgPSAoZXhpc3RpbmdSZWdFeHAsIHBhdHRlcm4pID0+IHtcbiAgICAgIGlmIChleGlzdGluZ1JlZ0V4cD8uc291cmNlID09PSBwYXR0ZXJuKSB7XG4gICAgICAgIGV4aXN0aW5nUmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1JlZ0V4cDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sICdnJyk7XG4gICAgfTtcbiAgICB0aGlzLnJlZ2V4cCA9IGdldE9yUmVzZXRSZWdFeHAodGhpcy5yZWdleHAsIGAke3RoaXMucHJlZml4fSguKz8pJHt0aGlzLnN1ZmZpeH1gKTtcbiAgICB0aGlzLnJlZ2V4cFVuZXNjYXBlID0gZ2V0T3JSZXNldFJlZ0V4cCh0aGlzLnJlZ2V4cFVuZXNjYXBlLCBgJHt0aGlzLnByZWZpeH0ke3RoaXMudW5lc2NhcGVQcmVmaXh9KC4rPykke3RoaXMudW5lc2NhcGVTdWZmaXh9JHt0aGlzLnN1ZmZpeH1gKTtcbiAgICB0aGlzLm5lc3RpbmdSZWdleHAgPSBnZXRPclJlc2V0UmVnRXhwKHRoaXMubmVzdGluZ1JlZ2V4cCwgYCR7dGhpcy5uZXN0aW5nUHJlZml4fSgoPzpbXigpXCInXSt8XCJbXlwiXSpcInwnW14nXSonfFxcXFwoKD86W14oKV18XCJbXlwiXSpcInwnW14nXSonKSpcXFxcKSkqPykke3RoaXMubmVzdGluZ1N1ZmZpeH1gKTtcbiAgfVxuICBpbnRlcnBvbGF0ZShzdHIsIGRhdGEsIGxuZywgb3B0aW9ucykge1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IHJlcGxhY2VzO1xuICAgIGNvbnN0IGRlZmF1bHREYXRhID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMgfHwge307XG4gICAgY29uc3QgaGFuZGxlRm9ybWF0ID0ga2V5ID0+IHtcbiAgICAgIGlmIChrZXkuaW5kZXhPZih0aGlzLmZvcm1hdFNlcGFyYXRvcikgPCAwKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBkZWVwRmluZFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwga2V5LCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFsd2F5c0Zvcm1hdCA/IHRoaXMuZm9ybWF0KHBhdGgsIHVuZGVmaW5lZCwgbG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIGludGVycG9sYXRpb25rZXk6IGtleVxuICAgICAgICB9KSA6IHBhdGg7XG4gICAgICB9XG4gICAgICBjb25zdCBwID0ga2V5LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICAgIGNvbnN0IGsgPSBwLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgY29uc3QgZiA9IHAuam9pbih0aGlzLmZvcm1hdFNlcGFyYXRvcikudHJpbSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZXBGaW5kV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrLCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSksIGYsIGxuZywge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBrXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcbiAgICBjb25zdCBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgPSBvcHRpb25zPy5taXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgfHwgdGhpcy5vcHRpb25zLm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcjtcbiAgICBjb25zdCBza2lwT25WYXJpYWJsZXMgPSBvcHRpb25zPy5pbnRlcnBvbGF0aW9uPy5za2lwT25WYXJpYWJsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgOiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXM7XG4gICAgY29uc3QgdG9kb3MgPSBbe1xuICAgICAgcmVnZXg6IHRoaXMucmVnZXhwVW5lc2NhcGUsXG4gICAgICBzYWZlVmFsdWU6IHZhbCA9PiByZWdleFNhZmUodmFsKVxuICAgIH0sIHtcbiAgICAgIHJlZ2V4OiB0aGlzLnJlZ2V4cCxcbiAgICAgIHNhZmVWYWx1ZTogdmFsID0+IHRoaXMuZXNjYXBlVmFsdWUgPyByZWdleFNhZmUodGhpcy5lc2NhcGUodmFsKSkgOiByZWdleFNhZmUodmFsKVxuICAgIH1dO1xuICAgIHRvZG9zLmZvckVhY2godG9kbyA9PiB7XG4gICAgICByZXBsYWNlcyA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggPSB0b2RvLnJlZ2V4LmV4ZWMoc3RyKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVkVmFyID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICB2YWx1ZSA9IGhhbmRsZUZvcm1hdChtYXRjaGVkVmFyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcihzdHIsIG1hdGNoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhbHVlID0gaXNTdHJpbmcodGVtcCkgPyB0ZW1wIDogJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBtYXRjaGVkVmFyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBtaXNzZWQgdG8gcGFzcyBpbiB2YXJpYWJsZSAke21hdGNoZWRWYXJ9IGZvciBpbnRlcnBvbGF0aW5nICR7c3RyfWApO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaW5nKHZhbHVlKSAmJiAhdGhpcy51c2VSYXdWYWx1ZVRvRXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYWZlVmFsdWUgPSB0b2RvLnNhZmVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCBzYWZlVmFsdWUpO1xuICAgICAgICBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZXMrKztcbiAgICAgICAgaWYgKHJlcGxhY2VzID49IHRoaXMubWF4UmVwbGFjZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbmVzdChzdHIsIGZjLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBjbG9uZWRPcHRpb25zO1xuICAgIGNvbnN0IGhhbmRsZUhhc09wdGlvbnMgPSAoa2V5LCBpbmhlcml0ZWRPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBzZXAgPSB0aGlzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yO1xuICAgICAgaWYgKGtleS5pbmRleE9mKHNlcCkgPCAwKSByZXR1cm4ga2V5O1xuICAgICAgY29uc3QgYyA9IGtleS5zcGxpdChuZXcgUmVnRXhwKGAke3NlcH1bIF0qe2ApKTtcbiAgICAgIGxldCBvcHRpb25zU3RyaW5nID0gYHske2NbMV19YDtcbiAgICAgIGtleSA9IGNbMF07XG4gICAgICBvcHRpb25zU3RyaW5nID0gdGhpcy5pbnRlcnBvbGF0ZShvcHRpb25zU3RyaW5nLCBjbG9uZWRPcHRpb25zKTtcbiAgICAgIGNvbnN0IG1hdGNoZWRTaW5nbGVRdW90ZXMgPSBvcHRpb25zU3RyaW5nLm1hdGNoKC8nL2cpO1xuICAgICAgY29uc3QgbWF0Y2hlZERvdWJsZVF1b3RlcyA9IG9wdGlvbnNTdHJpbmcubWF0Y2goL1wiL2cpO1xuICAgICAgaWYgKChtYXRjaGVkU2luZ2xlUXVvdGVzPy5sZW5ndGggPz8gMCkgJSAyID09PSAwICYmICFtYXRjaGVkRG91YmxlUXVvdGVzIHx8IG1hdGNoZWREb3VibGVRdW90ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBvcHRpb25zU3RyaW5nID0gb3B0aW9uc1N0cmluZy5yZXBsYWNlKC8nL2csICdcIicpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2xvbmVkT3B0aW9ucyA9IEpTT04ucGFyc2Uob3B0aW9uc1N0cmluZyk7XG4gICAgICAgIGlmIChpbmhlcml0ZWRPcHRpb25zKSBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAgIC4uLmluaGVyaXRlZE9wdGlvbnMsXG4gICAgICAgICAgLi4uY2xvbmVkT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBmYWlsZWQgcGFyc2luZyBvcHRpb25zIHN0cmluZyBpbiBuZXN0aW5nIGZvciBrZXkgJHtrZXl9YCwgZSk7XG4gICAgICAgIHJldHVybiBgJHtrZXl9JHtzZXB9JHtvcHRpb25zU3RyaW5nfWA7XG4gICAgICB9XG4gICAgICBpZiAoY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWUgJiYgY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWUuaW5kZXhPZih0aGlzLnByZWZpeCkgPiAtMSkgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIHdoaWxlIChtYXRjaCA9IHRoaXMubmVzdGluZ1JlZ2V4cC5leGVjKHN0cikpIHtcbiAgICAgIGxldCBmb3JtYXR0ZXJzID0gW107XG4gICAgICBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY2xvbmVkT3B0aW9ucyA9IGNsb25lZE9wdGlvbnMucmVwbGFjZSAmJiAhaXNTdHJpbmcoY2xvbmVkT3B0aW9ucy5yZXBsYWNlKSA/IGNsb25lZE9wdGlvbnMucmVwbGFjZSA6IGNsb25lZE9wdGlvbnM7XG4gICAgICBjbG9uZWRPcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgY29uc3Qga2V5RW5kSW5kZXggPSAvey4qfS8udGVzdChtYXRjaFsxXSkgPyBtYXRjaFsxXS5sYXN0SW5kZXhPZignfScpICsgMSA6IG1hdGNoWzFdLmluZGV4T2YodGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgICAgaWYgKGtleUVuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBmb3JtYXR0ZXJzID0gbWF0Y2hbMV0uc2xpY2Uoa2V5RW5kSW5kZXgpLnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKS5tYXAoZWxlbSA9PiBlbGVtLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnNsaWNlKDAsIGtleUVuZEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZmMoaGFuZGxlSGFzT3B0aW9ucy5jYWxsKHRoaXMsIG1hdGNoWzFdLnRyaW0oKSwgY2xvbmVkT3B0aW9ucyksIGNsb25lZE9wdGlvbnMpO1xuICAgICAgaWYgKHZhbHVlICYmIG1hdGNoWzBdID09PSBzdHIgJiYgIWlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHZhbHVlID0gbWFrZVN0cmluZyh2YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYG1pc3NlZCB0byByZXNvbHZlICR7bWF0Y2hbMV19IGZvciBuZXN0aW5nICR7c3RyfWApO1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVycy5yZWR1Y2UoKHYsIGYpID0+IHRoaXMuZm9ybWF0KHYsIGYsIG9wdGlvbnMubG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBtYXRjaFsxXS50cmltKClcbiAgICAgICAgfSksIHZhbHVlLnRyaW0oKSk7XG4gICAgICB9XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShtYXRjaFswXSwgdmFsdWUpO1xuICAgICAgdGhpcy5yZWdleHAubGFzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5jb25zdCBwYXJzZUZvcm1hdFN0ciA9IGZvcm1hdFN0ciA9PiB7XG4gIGxldCBmb3JtYXROYW1lID0gZm9ybWF0U3RyLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICBjb25zdCBmb3JtYXRPcHRpb25zID0ge307XG4gIGlmIChmb3JtYXRTdHIuaW5kZXhPZignKCcpID4gLTEpIHtcbiAgICBjb25zdCBwID0gZm9ybWF0U3RyLnNwbGl0KCcoJyk7XG4gICAgZm9ybWF0TmFtZSA9IHBbMF0udG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgY29uc3Qgb3B0U3RyID0gcFsxXS5zdWJzdHJpbmcoMCwgcFsxXS5sZW5ndGggLSAxKTtcbiAgICBpZiAoZm9ybWF0TmFtZSA9PT0gJ2N1cnJlbmN5JyAmJiBvcHRTdHIuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgaWYgKCFmb3JtYXRPcHRpb25zLmN1cnJlbmN5KSBmb3JtYXRPcHRpb25zLmN1cnJlbmN5ID0gb3B0U3RyLnRyaW0oKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdE5hbWUgPT09ICdyZWxhdGl2ZXRpbWUnICYmIG9wdFN0ci5pbmRleE9mKCc6JykgPCAwKSB7XG4gICAgICBpZiAoIWZvcm1hdE9wdGlvbnMucmFuZ2UpIGZvcm1hdE9wdGlvbnMucmFuZ2UgPSBvcHRTdHIudHJpbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcHRzID0gb3B0U3RyLnNwbGl0KCc7Jyk7XG4gICAgICBvcHRzLmZvckVhY2gob3B0ID0+IHtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gb3B0LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgY29uc3QgdmFsID0gcmVzdC5qb2luKCc6JykudHJpbSgpLnJlcGxhY2UoL14nK3wnKyQvZywgJycpO1xuICAgICAgICAgIGNvbnN0IHRyaW1tZWRLZXkgPSBrZXkudHJpbSgpO1xuICAgICAgICAgIGlmICghZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSkgZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSA9IHZhbDtcbiAgICAgICAgICBpZiAodmFsID09PSAnZmFsc2UnKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gJ3RydWUnKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbCkpIGZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0gPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZm9ybWF0TmFtZSxcbiAgICBmb3JtYXRPcHRpb25zXG4gIH07XG59O1xuY29uc3QgY3JlYXRlQ2FjaGVkRm9ybWF0dGVyID0gZm4gPT4ge1xuICBjb25zdCBjYWNoZSA9IHt9O1xuICByZXR1cm4gKHYsIGwsIG8pID0+IHtcbiAgICBsZXQgb3B0Rm9yQ2FjaGUgPSBvO1xuICAgIGlmIChvICYmIG8uaW50ZXJwb2xhdGlvbmtleSAmJiBvLmZvcm1hdFBhcmFtcyAmJiBvLmZvcm1hdFBhcmFtc1tvLmludGVycG9sYXRpb25rZXldICYmIG9bby5pbnRlcnBvbGF0aW9ua2V5XSkge1xuICAgICAgb3B0Rm9yQ2FjaGUgPSB7XG4gICAgICAgIC4uLm9wdEZvckNhY2hlLFxuICAgICAgICBbby5pbnRlcnBvbGF0aW9ua2V5XTogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBsICsgSlNPTi5zdHJpbmdpZnkob3B0Rm9yQ2FjaGUpO1xuICAgIGxldCBmcm0gPSBjYWNoZVtrZXldO1xuICAgIGlmICghZnJtKSB7XG4gICAgICBmcm0gPSBmbihnZXRDbGVhbmVkQ29kZShsKSwgbyk7XG4gICAgICBjYWNoZVtrZXldID0gZnJtO1xuICAgIH1cbiAgICByZXR1cm4gZnJtKHYpO1xuICB9O1xufTtcbmNvbnN0IGNyZWF0ZU5vbkNhY2hlZEZvcm1hdHRlciA9IGZuID0+ICh2LCBsLCBvKSA9PiBmbihnZXRDbGVhbmVkQ29kZShsKSwgbykodik7XG5jbGFzcyBGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdmb3JtYXR0ZXInKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KHNlcnZpY2VzLCBvcHRpb25zID0ge1xuICAgIGludGVycG9sYXRpb246IHt9XG4gIH0pIHtcbiAgICB0aGlzLmZvcm1hdFNlcGFyYXRvciA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICAgIGNvbnN0IGNmID0gb3B0aW9ucy5jYWNoZUluQnVpbHRGb3JtYXRzID8gY3JlYXRlQ2FjaGVkRm9ybWF0dGVyIDogY3JlYXRlTm9uQ2FjaGVkRm9ybWF0dGVyO1xuICAgIHRoaXMuZm9ybWF0cyA9IHtcbiAgICAgIG51bWJlcjogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBjdXJyZW5jeTogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBkYXRldGltZTogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIHJlbGF0aXZldGltZTogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwsIG9wdC5yYW5nZSB8fCAnZGF5Jyk7XG4gICAgICB9KSxcbiAgICAgIGxpc3Q6IGNmKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgYWRkKG5hbWUsIGZjKSB7XG4gICAgdGhpcy5mb3JtYXRzW25hbWUudG9Mb3dlckNhc2UoKS50cmltKCldID0gZmM7XG4gIH1cbiAgYWRkQ2FjaGVkKG5hbWUsIGZjKSB7XG4gICAgdGhpcy5mb3JtYXRzW25hbWUudG9Mb3dlckNhc2UoKS50cmltKCldID0gY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKGZjKTtcbiAgfVxuICBmb3JtYXQodmFsdWUsIGZvcm1hdCwgbG5nLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBmb3JtYXRzID0gZm9ybWF0LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICBpZiAoZm9ybWF0cy5sZW5ndGggPiAxICYmIGZvcm1hdHNbMF0uaW5kZXhPZignKCcpID4gMSAmJiBmb3JtYXRzWzBdLmluZGV4T2YoJyknKSA8IDAgJiYgZm9ybWF0cy5maW5kKGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSkpIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGZvcm1hdHMuZmluZEluZGV4KGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSk7XG4gICAgICBmb3JtYXRzWzBdID0gW2Zvcm1hdHNbMF0sIC4uLmZvcm1hdHMuc3BsaWNlKDEsIGxhc3RJbmRleCldLmpvaW4odGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRzLnJlZHVjZSgobWVtLCBmKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvcm1hdE5hbWUsXG4gICAgICAgIGZvcm1hdE9wdGlvbnNcbiAgICAgIH0gPSBwYXJzZUZvcm1hdFN0cihmKTtcbiAgICAgIGlmICh0aGlzLmZvcm1hdHNbZm9ybWF0TmFtZV0pIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9IG1lbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWxPcHRpb25zID0gb3B0aW9ucz8uZm9ybWF0UGFyYW1zPy5bb3B0aW9ucy5pbnRlcnBvbGF0aW9ua2V5XSB8fCB7fTtcbiAgICAgICAgICBjb25zdCBsID0gdmFsT3B0aW9ucy5sb2NhbGUgfHwgdmFsT3B0aW9ucy5sbmcgfHwgb3B0aW9ucy5sb2NhbGUgfHwgb3B0aW9ucy5sbmcgfHwgbG5nO1xuICAgICAgICAgIGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0c1tmb3JtYXROYW1lXShtZW0sIGwsIHtcbiAgICAgICAgICAgIC4uLmZvcm1hdE9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgLi4udmFsT3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGB0aGVyZSB3YXMgbm8gZm9ybWF0IGZ1bmN0aW9uIGZvciAke2Zvcm1hdE5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtO1xuICAgIH0sIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmNvbnN0IHJlbW92ZVBlbmRpbmcgPSAocSwgbmFtZSkgPT4ge1xuICBpZiAocS5wZW5kaW5nW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgcS5wZW5kaW5nW25hbWVdO1xuICAgIHEucGVuZGluZ0NvdW50LS07XG4gIH1cbn07XG5jbGFzcyBDb25uZWN0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihiYWNrZW5kLCBzdG9yZSwgc2VydmljZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgIHRoaXMubGFuZ3VhZ2VVdGlscyA9IHNlcnZpY2VzLmxhbmd1YWdlVXRpbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdiYWNrZW5kQ29ubmVjdG9yJyk7XG4gICAgdGhpcy53YWl0aW5nUmVhZHMgPSBbXTtcbiAgICB0aGlzLm1heFBhcmFsbGVsUmVhZHMgPSBvcHRpb25zLm1heFBhcmFsbGVsUmVhZHMgfHwgMTA7XG4gICAgdGhpcy5yZWFkaW5nQ2FsbHMgPSAwO1xuICAgIHRoaXMubWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA+PSAwID8gb3B0aW9ucy5tYXhSZXRyaWVzIDogNTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IG9wdGlvbnMucmV0cnlUaW1lb3V0ID49IDEgPyBvcHRpb25zLnJldHJ5VGltZW91dCA6IDM1MDtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuYmFja2VuZD8uaW5pdD8uKHNlcnZpY2VzLCBvcHRpb25zLmJhY2tlbmQsIG9wdGlvbnMpO1xuICB9XG4gIHF1ZXVlTG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdG9Mb2FkID0ge307XG4gICAgY29uc3QgcGVuZGluZyA9IHt9O1xuICAgIGNvbnN0IHRvTG9hZExhbmd1YWdlcyA9IHt9O1xuICAgIGNvbnN0IHRvTG9hZE5hbWVzcGFjZXMgPSB7fTtcbiAgICBsYW5ndWFnZXMuZm9yRWFjaChsbmcgPT4ge1xuICAgICAgbGV0IGhhc0FsbE5hbWVzcGFjZXMgPSB0cnVlO1xuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKG5zID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGAke2xuZ318JHtuc31gO1xuICAgICAgICBpZiAoIW9wdGlvbnMucmVsb2FkICYmIHRoaXMuc3RvcmUuaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlW25hbWVdID0gMjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlW25hbWVdIDwgMCkgOyBlbHNlIGlmICh0aGlzLnN0YXRlW25hbWVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmdbbmFtZV0gPT09IHVuZGVmaW5lZCkgcGVuZGluZ1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZVtuYW1lXSA9IDE7XG4gICAgICAgICAgaGFzQWxsTmFtZXNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChwZW5kaW5nW25hbWVdID09PSB1bmRlZmluZWQpIHBlbmRpbmdbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGlmICh0b0xvYWRbbmFtZV0gPT09IHVuZGVmaW5lZCkgdG9Mb2FkW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodG9Mb2FkTmFtZXNwYWNlc1tuc10gPT09IHVuZGVmaW5lZCkgdG9Mb2FkTmFtZXNwYWNlc1tuc10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghaGFzQWxsTmFtZXNwYWNlcykgdG9Mb2FkTGFuZ3VhZ2VzW2xuZ10gPSB0cnVlO1xuICAgIH0pO1xuICAgIGlmIChPYmplY3Qua2V5cyh0b0xvYWQpLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhwZW5kaW5nKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh7XG4gICAgICAgIHBlbmRpbmcsXG4gICAgICAgIHBlbmRpbmdDb3VudDogT2JqZWN0LmtleXMocGVuZGluZykubGVuZ3RoLFxuICAgICAgICBsb2FkZWQ6IHt9LFxuICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0b0xvYWQ6IE9iamVjdC5rZXlzKHRvTG9hZCksXG4gICAgICBwZW5kaW5nOiBPYmplY3Qua2V5cyhwZW5kaW5nKSxcbiAgICAgIHRvTG9hZExhbmd1YWdlczogT2JqZWN0LmtleXModG9Mb2FkTGFuZ3VhZ2VzKSxcbiAgICAgIHRvTG9hZE5hbWVzcGFjZXM6IE9iamVjdC5rZXlzKHRvTG9hZE5hbWVzcGFjZXMpXG4gICAgfTtcbiAgfVxuICBsb2FkZWQobmFtZSwgZXJyLCBkYXRhKSB7XG4gICAgY29uc3QgcyA9IG5hbWUuc3BsaXQoJ3wnKTtcbiAgICBjb25zdCBsbmcgPSBzWzBdO1xuICAgIGNvbnN0IG5zID0gc1sxXTtcbiAgICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2ZhaWxlZExvYWRpbmcnLCBsbmcsIG5zLCBlcnIpO1xuICAgIGlmICghZXJyICYmIGRhdGEpIHtcbiAgICAgIHRoaXMuc3RvcmUuYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBucywgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgc2tpcENvcHk6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlW25hbWVdID0gZXJyID8gLTEgOiAyO1xuICAgIGlmIChlcnIgJiYgZGF0YSkgdGhpcy5zdGF0ZVtuYW1lXSA9IDA7XG4gICAgY29uc3QgbG9hZGVkID0ge307XG4gICAgdGhpcy5xdWV1ZS5mb3JFYWNoKHEgPT4ge1xuICAgICAgcHVzaFBhdGgocS5sb2FkZWQsIFtsbmddLCBucyk7XG4gICAgICByZW1vdmVQZW5kaW5nKHEsIG5hbWUpO1xuICAgICAgaWYgKGVycikgcS5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgaWYgKHEucGVuZGluZ0NvdW50ID09PSAwICYmICFxLmRvbmUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocS5sb2FkZWQpLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgaWYgKCFsb2FkZWRbbF0pIGxvYWRlZFtsXSA9IHt9O1xuICAgICAgICAgIGNvbnN0IGxvYWRlZEtleXMgPSBxLmxvYWRlZFtsXTtcbiAgICAgICAgICBpZiAobG9hZGVkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvYWRlZEtleXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgaWYgKGxvYWRlZFtsXVtuXSA9PT0gdW5kZWZpbmVkKSBsb2FkZWRbbF1bbl0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcS5kb25lID0gdHJ1ZTtcbiAgICAgICAgaWYgKHEuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHEuY2FsbGJhY2socS5lcnJvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHEuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgbG9hZGVkKTtcbiAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5maWx0ZXIocSA9PiAhcS5kb25lKTtcbiAgfVxuICByZWFkKGxuZywgbnMsIGZjTmFtZSwgdHJpZWQgPSAwLCB3YWl0ID0gdGhpcy5yZXRyeVRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFsbmcubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2sobnVsbCwge30pO1xuICAgIGlmICh0aGlzLnJlYWRpbmdDYWxscyA+PSB0aGlzLm1heFBhcmFsbGVsUmVhZHMpIHtcbiAgICAgIHRoaXMud2FpdGluZ1JlYWRzLnB1c2goe1xuICAgICAgICBsbmcsXG4gICAgICAgIG5zLFxuICAgICAgICBmY05hbWUsXG4gICAgICAgIHRyaWVkLFxuICAgICAgICB3YWl0LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVhZGluZ0NhbGxzKys7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICB0aGlzLnJlYWRpbmdDYWxscy0tO1xuICAgICAgaWYgKHRoaXMud2FpdGluZ1JlYWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMud2FpdGluZ1JlYWRzLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMucmVhZChuZXh0LmxuZywgbmV4dC5ucywgbmV4dC5mY05hbWUsIG5leHQudHJpZWQsIG5leHQud2FpdCwgbmV4dC5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyICYmIGRhdGEgJiYgdHJpZWQgPCB0aGlzLm1heFJldHJpZXMpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWFkLmNhbGwodGhpcywgbG5nLCBucywgZmNOYW1lLCB0cmllZCArIDEsIHdhaXQgKiAyLCBjYWxsYmFjayk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgIH07XG4gICAgY29uc3QgZmMgPSB0aGlzLmJhY2tlbmRbZmNOYW1lXS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgaWYgKGZjLmxlbmd0aCA9PT0gMikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgciA9IGZjKGxuZywgbnMpO1xuICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgci50aGVuKGRhdGEgPT4gcmVzb2x2ZXIobnVsbCwgZGF0YSkpLmNhdGNoKHJlc29sdmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlcihudWxsLCByKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc29sdmVyKGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmYyhsbmcsIG5zLCByZXNvbHZlcik7XG4gIH1cbiAgcHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zID0ge30sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmJhY2tlbmQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIGJhY2tlbmQgd2FzIGFkZGVkIHZpYSBpMThuZXh0LnVzZS4gV2lsbCBub3QgbG9hZCByZXNvdXJjZXMuJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGxhbmd1YWdlcykpIGxhbmd1YWdlcyA9IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobGFuZ3VhZ2VzKTtcbiAgICBpZiAoaXNTdHJpbmcobmFtZXNwYWNlcykpIG5hbWVzcGFjZXMgPSBbbmFtZXNwYWNlc107XG4gICAgY29uc3QgdG9Mb2FkID0gdGhpcy5xdWV1ZUxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgaWYgKCF0b0xvYWQudG9Mb2FkLmxlbmd0aCkge1xuICAgICAgaWYgKCF0b0xvYWQucGVuZGluZy5sZW5ndGgpIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9Mb2FkLnRvTG9hZC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgdGhpcy5sb2FkT25lKG5hbWUpO1xuICAgIH0pO1xuICB9XG4gIGxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBjYWxsYmFjaykge1xuICAgIHRoaXMucHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCB7fSwgY2FsbGJhY2spO1xuICB9XG4gIHJlbG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIHtcbiAgICAgIHJlbG9hZDogdHJ1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbiAgfVxuICBsb2FkT25lKG5hbWUsIHByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgcyA9IG5hbWUuc3BsaXQoJ3wnKTtcbiAgICBjb25zdCBsbmcgPSBzWzBdO1xuICAgIGNvbnN0IG5zID0gc1sxXTtcbiAgICB0aGlzLnJlYWQobG5nLCBucywgJ3JlYWQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycikgdGhpcy5sb2dnZXIud2FybihgJHtwcmVmaXh9bG9hZGluZyBuYW1lc3BhY2UgJHtuc30gZm9yIGxhbmd1YWdlICR7bG5nfSBmYWlsZWRgLCBlcnIpO1xuICAgICAgaWYgKCFlcnIgJiYgZGF0YSkgdGhpcy5sb2dnZXIubG9nKGAke3ByZWZpeH1sb2FkZWQgbmFtZXNwYWNlICR7bnN9IGZvciBsYW5ndWFnZSAke2xuZ31gLCBkYXRhKTtcbiAgICAgIHRoaXMubG9hZGVkKG5hbWUsIGVyciwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgc2F2ZU1pc3NpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSwgaXNVcGRhdGUsIG9wdGlvbnMgPSB7fSwgY2xiID0gKCkgPT4ge30pIHtcbiAgICBpZiAodGhpcy5zZXJ2aWNlcz8udXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZSAmJiAhdGhpcy5zZXJ2aWNlcz8udXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZShuYW1lc3BhY2UpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBkaWQgbm90IHNhdmUga2V5IFwiJHtrZXl9XCIgYXMgdGhlIG5hbWVzcGFjZSBcIiR7bmFtZXNwYWNlfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCB8fCBrZXkgPT09ICcnKSByZXR1cm47XG4gICAgaWYgKHRoaXMuYmFja2VuZD8uY3JlYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBpc1VwZGF0ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZjID0gdGhpcy5iYWNrZW5kLmNyZWF0ZS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgICBpZiAoZmMubGVuZ3RoIDwgNikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCByO1xuICAgICAgICAgIGlmIChmYy5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgIHIgPSBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBvcHRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByLnRoZW4oZGF0YSA9PiBjbGIobnVsbCwgZGF0YSkpLmNhdGNoKGNsYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYihudWxsLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNsYihlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBjbGIsIG9wdHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWxhbmd1YWdlcyB8fCAhbGFuZ3VhZ2VzWzBdKSByZXR1cm47XG4gICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZShsYW5ndWFnZXNbMF0sIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlKTtcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoKSA9PiAoe1xuICBkZWJ1ZzogZmFsc2UsXG4gIGluaXRBc3luYzogdHJ1ZSxcbiAgbnM6IFsndHJhbnNsYXRpb24nXSxcbiAgZGVmYXVsdE5TOiBbJ3RyYW5zbGF0aW9uJ10sXG4gIGZhbGxiYWNrTG5nOiBbJ2RldiddLFxuICBmYWxsYmFja05TOiBmYWxzZSxcbiAgc3VwcG9ydGVkTG5nczogZmFsc2UsXG4gIG5vbkV4cGxpY2l0U3VwcG9ydGVkTG5nczogZmFsc2UsXG4gIGxvYWQ6ICdhbGwnLFxuICBwcmVsb2FkOiBmYWxzZSxcbiAgc2ltcGxpZnlQbHVyYWxTdWZmaXg6IHRydWUsXG4gIGtleVNlcGFyYXRvcjogJy4nLFxuICBuc1NlcGFyYXRvcjogJzonLFxuICBwbHVyYWxTZXBhcmF0b3I6ICdfJyxcbiAgY29udGV4dFNlcGFyYXRvcjogJ18nLFxuICBwYXJ0aWFsQnVuZGxlZExhbmd1YWdlczogZmFsc2UsXG4gIHNhdmVNaXNzaW5nOiBmYWxzZSxcbiAgdXBkYXRlTWlzc2luZzogZmFsc2UsXG4gIHNhdmVNaXNzaW5nVG86ICdmYWxsYmFjaycsXG4gIHNhdmVNaXNzaW5nUGx1cmFsczogdHJ1ZSxcbiAgbWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXI6IGZhbHNlLFxuICBwb3N0UHJvY2VzczogZmFsc2UsXG4gIHBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkOiBmYWxzZSxcbiAgcmV0dXJuTnVsbDogZmFsc2UsXG4gIHJldHVybkVtcHR5U3RyaW5nOiB0cnVlLFxuICByZXR1cm5PYmplY3RzOiBmYWxzZSxcbiAgam9pbkFycmF5czogZmFsc2UsXG4gIHJldHVybmVkT2JqZWN0SGFuZGxlcjogZmFsc2UsXG4gIHBhcnNlTWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICBhcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXk6IGZhbHNlLFxuICBhcHBlbmROYW1lc3BhY2VUb0NJTW9kZTogZmFsc2UsXG4gIG92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyOiBhcmdzID0+IHtcbiAgICBsZXQgcmV0ID0ge307XG4gICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0JykgcmV0ID0gYXJnc1sxXTtcbiAgICBpZiAoaXNTdHJpbmcoYXJnc1sxXSkpIHJldC5kZWZhdWx0VmFsdWUgPSBhcmdzWzFdO1xuICAgIGlmIChpc1N0cmluZyhhcmdzWzJdKSkgcmV0LnREZXNjcmlwdGlvbiA9IGFyZ3NbMl07XG4gICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgYXJnc1szXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzNdIHx8IGFyZ3NbMl07XG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHJldFtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGludGVycG9sYXRpb246IHtcbiAgICBlc2NhcGVWYWx1ZTogdHJ1ZSxcbiAgICBmb3JtYXQ6IHZhbHVlID0+IHZhbHVlLFxuICAgIHByZWZpeDogJ3t7JyxcbiAgICBzdWZmaXg6ICd9fScsXG4gICAgZm9ybWF0U2VwYXJhdG9yOiAnLCcsXG4gICAgdW5lc2NhcGVQcmVmaXg6ICctJyxcbiAgICBuZXN0aW5nUHJlZml4OiAnJHQoJyxcbiAgICBuZXN0aW5nU3VmZml4OiAnKScsXG4gICAgbmVzdGluZ09wdGlvbnNTZXBhcmF0b3I6ICcsJyxcbiAgICBtYXhSZXBsYWNlczogMTAwMCxcbiAgICBza2lwT25WYXJpYWJsZXM6IHRydWVcbiAgfSxcbiAgY2FjaGVJbkJ1aWx0Rm9ybWF0czogdHJ1ZVxufSk7XG5jb25zdCB0cmFuc2Zvcm1PcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmIChpc1N0cmluZyhvcHRpb25zLm5zKSkgb3B0aW9ucy5ucyA9IFtvcHRpb25zLm5zXTtcbiAgaWYgKGlzU3RyaW5nKG9wdGlvbnMuZmFsbGJhY2tMbmcpKSBvcHRpb25zLmZhbGxiYWNrTG5nID0gW29wdGlvbnMuZmFsbGJhY2tMbmddO1xuICBpZiAoaXNTdHJpbmcob3B0aW9ucy5mYWxsYmFja05TKSkgb3B0aW9ucy5mYWxsYmFja05TID0gW29wdGlvbnMuZmFsbGJhY2tOU107XG4gIGlmIChvcHRpb25zLnN1cHBvcnRlZExuZ3M/LmluZGV4T2Y/LignY2ltb2RlJykgPCAwKSB7XG4gICAgb3B0aW9ucy5zdXBwb3J0ZWRMbmdzID0gb3B0aW9ucy5zdXBwb3J0ZWRMbmdzLmNvbmNhdChbJ2NpbW9kZSddKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5pdEltbWVkaWF0ZSA9PT0gJ2Jvb2xlYW4nKSBvcHRpb25zLmluaXRBc3luYyA9IG9wdGlvbnMuaW5pdEltbWVkaWF0ZTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCBiaW5kTWVtYmVyRnVuY3Rpb25zID0gaW5zdCA9PiB7XG4gIGNvbnN0IG1lbXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdCkpO1xuICBtZW1zLmZvckVhY2gobWVtID0+IHtcbiAgICBpZiAodHlwZW9mIGluc3RbbWVtXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdFttZW1dID0gaW5zdFttZW1dLmJpbmQoaW5zdCk7XG4gICAgfVxuICB9KTtcbn07XG5jbGFzcyBJMThuIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNlcnZpY2VzID0ge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyO1xuICAgIHRoaXMubW9kdWxlcyA9IHtcbiAgICAgIGV4dGVybmFsOiBbXVxuICAgIH07XG4gICAgYmluZE1lbWJlckZ1bmN0aW9ucyh0aGlzKTtcbiAgICBpZiAoY2FsbGJhY2sgJiYgIXRoaXMuaXNJbml0aWFsaXplZCAmJiAhb3B0aW9ucy5pc0Nsb25lKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbml0QXN5bmMpIHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBpbml0KG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGVmYXVsdE5TID09IG51bGwgJiYgb3B0aW9ucy5ucykge1xuICAgICAgaWYgKGlzU3RyaW5nKG9wdGlvbnMubnMpKSB7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdE5TID0gb3B0aW9ucy5ucztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ucy5pbmRleE9mKCd0cmFuc2xhdGlvbicpIDwgMCkge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHROUyA9IG9wdGlvbnMubnNbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlZk9wdHMgPSBnZXQoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZPcHRzLFxuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4udHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgICAuLi5kZWZPcHRzLmludGVycG9sYXRpb24sXG4gICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvblxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51c2VyRGVmaW5lZEtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uc1NlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXNlckRlZmluZWROc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IGNyZWF0ZUNsYXNzT25EZW1hbmQgPSBDbGFzc09yT2JqZWN0ID0+IHtcbiAgICAgIGlmICghQ2xhc3NPck9iamVjdCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIENsYXNzT3JPYmplY3QgPT09ICdmdW5jdGlvbicpIHJldHVybiBuZXcgQ2xhc3NPck9iamVjdCgpO1xuICAgICAgcmV0dXJuIENsYXNzT3JPYmplY3Q7XG4gICAgfTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0Nsb25lKSB7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmxvZ2dlcikge1xuICAgICAgICBiYXNlTG9nZ2VyLmluaXQoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMubG9nZ2VyKSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VMb2dnZXIuaW5pdChudWxsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgbGV0IGZvcm1hdHRlcjtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMuZm9ybWF0dGVyKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IHRoaXMubW9kdWxlcy5mb3JtYXR0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXR0ZXIgPSBGb3JtYXR0ZXI7XG4gICAgICB9XG4gICAgICBjb25zdCBsdSA9IG5ldyBMYW5ndWFnZVV0aWwodGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuc3RvcmUgPSBuZXcgUmVzb3VyY2VTdG9yZSh0aGlzLm9wdGlvbnMucmVzb3VyY2VzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgY29uc3QgcyA9IHRoaXMuc2VydmljZXM7XG4gICAgICBzLmxvZ2dlciA9IGJhc2VMb2dnZXI7XG4gICAgICBzLnJlc291cmNlU3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgcy5sYW5ndWFnZVV0aWxzID0gbHU7XG4gICAgICBzLnBsdXJhbFJlc29sdmVyID0gbmV3IFBsdXJhbFJlc29sdmVyKGx1LCB7XG4gICAgICAgIHByZXBlbmQ6IHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IsXG4gICAgICAgIHNpbXBsaWZ5UGx1cmFsU3VmZml4OiB0aGlzLm9wdGlvbnMuc2ltcGxpZnlQbHVyYWxTdWZmaXhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdXNpbmdMZWdhY3lGb3JtYXRGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCAmJiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgIT09IGRlZk9wdHMuaW50ZXJwb2xhdGlvbi5mb3JtYXQ7XG4gICAgICBpZiAodXNpbmdMZWdhY3lGb3JtYXRGdW5jdGlvbikge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZXByZWNhdGUoYGluaXQ6IHlvdSBhcmUgc3RpbGwgdXNpbmcgdGhlIGxlZ2FjeSBmb3JtYXQgZnVuY3Rpb24sIHBsZWFzZSB1c2UgdGhlIG5ldyBhcHByb2FjaDogaHR0cHM6Ly93d3cuaTE4bmV4dC5jb20vdHJhbnNsYXRpb24tZnVuY3Rpb24vZm9ybWF0dGluZ2ApO1xuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdHRlciAmJiAoIXRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCB8fCB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgPT09IGRlZk9wdHMuaW50ZXJwb2xhdGlvbi5mb3JtYXQpKSB7XG4gICAgICAgIHMuZm9ybWF0dGVyID0gY3JlYXRlQ2xhc3NPbkRlbWFuZChmb3JtYXR0ZXIpO1xuICAgICAgICBpZiAocy5mb3JtYXR0ZXIuaW5pdCkgcy5mb3JtYXR0ZXIuaW5pdChzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgPSBzLmZvcm1hdHRlci5mb3JtYXQuYmluZChzLmZvcm1hdHRlcik7XG4gICAgICB9XG4gICAgICBzLmludGVycG9sYXRvciA9IG5ldyBJbnRlcnBvbGF0b3IodGhpcy5vcHRpb25zKTtcbiAgICAgIHMudXRpbHMgPSB7XG4gICAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogdGhpcy5oYXNMb2FkZWROYW1lc3BhY2UuYmluZCh0aGlzKVxuICAgICAgfTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3IoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMuYmFja2VuZCksIHMucmVzb3VyY2VTdG9yZSwgcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3Rvci5vbignKicsIChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmxhbmd1YWdlRGV0ZWN0b3IpIHtcbiAgICAgICAgcy5sYW5ndWFnZURldGVjdG9yID0gY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3Rvcik7XG4gICAgICAgIGlmIChzLmxhbmd1YWdlRGV0ZWN0b3IuaW5pdCkgcy5sYW5ndWFnZURldGVjdG9yLmluaXQocywgdGhpcy5vcHRpb25zLmRldGVjdGlvbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1vZHVsZXMuaTE4bkZvcm1hdCkge1xuICAgICAgICBzLmkxOG5Gb3JtYXQgPSBjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5pMThuRm9ybWF0KTtcbiAgICAgICAgaWYgKHMuaTE4bkZvcm1hdC5pbml0KSBzLmkxOG5Gb3JtYXQuaW5pdCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKHRoaXMuc2VydmljZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnRyYW5zbGF0b3Iub24oJyonLCAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tb2R1bGVzLmV4dGVybmFsLmZvckVhY2gobSA9PiB7XG4gICAgICAgIGlmIChtLmluaXQpIG0uaW5pdCh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdCA9IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdDtcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyAmJiAhdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLm9wdGlvbnMubG5nKSB7XG4gICAgICBjb25zdCBjb2RlcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICBpZiAoY29kZXMubGVuZ3RoID4gMCAmJiBjb2Rlc1swXSAhPT0gJ2RldicpIHRoaXMub3B0aW9ucy5sbmcgPSBjb2Rlc1swXTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMub3B0aW9ucy5sbmcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2luaXQ6IG5vIGxhbmd1YWdlRGV0ZWN0b3IgaXMgdXNlZCBhbmQgbm8gbG5nIGlzIGRlZmluZWQnKTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVBcGkgPSBbJ2dldFJlc291cmNlJywgJ2hhc1Jlc291cmNlQnVuZGxlJywgJ2dldFJlc291cmNlQnVuZGxlJywgJ2dldERhdGFCeUxhbmd1YWdlJ107XG4gICAgc3RvcmVBcGkuZm9yRWFjaChmY05hbWUgPT4ge1xuICAgICAgdGhpc1tmY05hbWVdID0gKC4uLmFyZ3MpID0+IHRoaXMuc3RvcmVbZmNOYW1lXSguLi5hcmdzKTtcbiAgICB9KTtcbiAgICBjb25zdCBzdG9yZUFwaUNoYWluZWQgPSBbJ2FkZFJlc291cmNlJywgJ2FkZFJlc291cmNlcycsICdhZGRSZXNvdXJjZUJ1bmRsZScsICdyZW1vdmVSZXNvdXJjZUJ1bmRsZSddO1xuICAgIHN0b3JlQXBpQ2hhaW5lZC5mb3JFYWNoKGZjTmFtZSA9PiB7XG4gICAgICB0aGlzW2ZjTmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICB0aGlzLnN0b3JlW2ZjTmFtZV0oLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbmlzaCA9IChlcnIsIHQpID0+IHtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkICYmICF0aGlzLmluaXRpYWxpemVkU3RvcmVPbmNlKSB0aGlzLmxvZ2dlci53YXJuKCdpbml0OiBpMThuZXh0IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIFlvdSBzaG91bGQgY2FsbCBpbml0IGp1c3Qgb25jZSEnKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNDbG9uZSkgdGhpcy5sb2dnZXIubG9nKCdpbml0aWFsaXplZCcsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdCgnaW5pdGlhbGl6ZWQnLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHQpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHQpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxhbmd1YWdlcyAmJiAhdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gZmluaXNoKG51bGwsIHRoaXMudC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuY2hhbmdlTGFuZ3VhZ2UodGhpcy5vcHRpb25zLmxuZywgZmluaXNoKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzb3VyY2VzIHx8ICF0aGlzLm9wdGlvbnMuaW5pdEFzeW5jKSB7XG4gICAgICBsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQobG9hZCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBsb2FkUmVzb3VyY2VzKGxhbmd1YWdlLCBjYWxsYmFjayA9IG5vb3ApIHtcbiAgICBsZXQgdXNlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgY29uc3QgdXNlZExuZyA9IGlzU3RyaW5nKGxhbmd1YWdlKSA/IGxhbmd1YWdlIDogdGhpcy5sYW5ndWFnZTtcbiAgICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSAnZnVuY3Rpb24nKSB1c2VkQ2FsbGJhY2sgPSBsYW5ndWFnZTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXNvdXJjZXMgfHwgdGhpcy5vcHRpb25zLnBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzKSB7XG4gICAgICBpZiAodXNlZExuZz8udG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScgJiYgKCF0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCB0aGlzLm9wdGlvbnMucHJlbG9hZC5sZW5ndGggPT09IDApKSByZXR1cm4gdXNlZENhbGxiYWNrKCk7XG4gICAgICBjb25zdCB0b0xvYWQgPSBbXTtcbiAgICAgIGNvbnN0IGFwcGVuZCA9IGxuZyA9PiB7XG4gICAgICAgIGlmICghbG5nKSByZXR1cm47XG4gICAgICAgIGlmIChsbmcgPT09ICdjaW1vZGUnKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxuZ3MgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxuZyk7XG4gICAgICAgIGxuZ3MuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICBpZiAobCA9PT0gJ2NpbW9kZScpIHJldHVybjtcbiAgICAgICAgICBpZiAodG9Mb2FkLmluZGV4T2YobCkgPCAwKSB0b0xvYWQucHVzaChsKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKCF1c2VkTG5nKSB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICAgIGZhbGxiYWNrcy5mb3JFYWNoKGwgPT4gYXBwZW5kKGwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCh1c2VkTG5nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucy5wcmVsb2FkPy5mb3JFYWNoPy4obCA9PiBhcHBlbmQobCkpO1xuICAgICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLmxvYWQodG9Mb2FkLCB0aGlzLm9wdGlvbnMubnMsIGUgPT4ge1xuICAgICAgICBpZiAoIWUgJiYgIXRoaXMucmVzb2x2ZWRMYW5ndWFnZSAmJiB0aGlzLmxhbmd1YWdlKSB0aGlzLnNldFJlc29sdmVkTGFuZ3VhZ2UodGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIHVzZWRDYWxsYmFjayhlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VkQ2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICB9XG4gIHJlbG9hZFJlc291cmNlcyhsbmdzLCBucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKHR5cGVvZiBsbmdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGxuZ3M7XG4gICAgICBsbmdzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG5zO1xuICAgICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghbG5ncykgbG5ncyA9IHRoaXMubGFuZ3VhZ2VzO1xuICAgIGlmICghbnMpIG5zID0gdGhpcy5vcHRpb25zLm5zO1xuICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gbm9vcDtcbiAgICB0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IucmVsb2FkKGxuZ3MsIG5zLCBlcnIgPT4ge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgdXNlKG1vZHVsZSkge1xuICAgIGlmICghbW9kdWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgcGFzc2luZyBhbiB1bmRlZmluZWQgbW9kdWxlISBQbGVhc2UgY2hlY2sgdGhlIG9iamVjdCB5b3UgYXJlIHBhc3NpbmcgdG8gaTE4bmV4dC51c2UoKScpO1xuICAgIGlmICghbW9kdWxlLnR5cGUpIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBwYXNzaW5nIGEgd3JvbmcgbW9kdWxlISBQbGVhc2UgY2hlY2sgdGhlIG9iamVjdCB5b3UgYXJlIHBhc3NpbmcgdG8gaTE4bmV4dC51c2UoKScpO1xuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2JhY2tlbmQnKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuYmFja2VuZCA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnbG9nZ2VyJyB8fCBtb2R1bGUubG9nICYmIG1vZHVsZS53YXJuICYmIG1vZHVsZS5lcnJvcikge1xuICAgICAgdGhpcy5tb2R1bGVzLmxvZ2dlciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnbGFuZ3VhZ2VEZXRlY3RvcicpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdpMThuRm9ybWF0Jykge1xuICAgICAgdGhpcy5tb2R1bGVzLmkxOG5Gb3JtYXQgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ3Bvc3RQcm9jZXNzb3InKSB7XG4gICAgICBwb3N0UHJvY2Vzc29yLmFkZFBvc3RQcm9jZXNzb3IobW9kdWxlKTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnZm9ybWF0dGVyJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmZvcm1hdHRlciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnM3JkUGFydHknKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuZXh0ZXJuYWwucHVzaChtb2R1bGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRSZXNvbHZlZExhbmd1YWdlKGwpIHtcbiAgICBpZiAoIWwgfHwgIXRoaXMubGFuZ3VhZ2VzKSByZXR1cm47XG4gICAgaWYgKFsnY2ltb2RlJywgJ2RldiddLmluZGV4T2YobCkgPiAtMSkgcmV0dXJuO1xuICAgIGZvciAobGV0IGxpID0gMDsgbGkgPCB0aGlzLmxhbmd1YWdlcy5sZW5ndGg7IGxpKyspIHtcbiAgICAgIGNvbnN0IGxuZ0luTG5ncyA9IHRoaXMubGFuZ3VhZ2VzW2xpXTtcbiAgICAgIGlmIChbJ2NpbW9kZScsICdkZXYnXS5pbmRleE9mKGxuZ0luTG5ncykgPiAtMSkgY29udGludWU7XG4gICAgICBpZiAodGhpcy5zdG9yZS5oYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMobG5nSW5MbmdzKSkge1xuICAgICAgICB0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgPSBsbmdJbkxuZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucmVzb2x2ZWRMYW5ndWFnZSAmJiB0aGlzLmxhbmd1YWdlcy5pbmRleE9mKGwpIDwgMCAmJiB0aGlzLnN0b3JlLmhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhsKSkge1xuICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gbDtcbiAgICAgIHRoaXMubGFuZ3VhZ2VzLnVuc2hpZnQobCk7XG4gICAgfVxuICB9XG4gIGNoYW5nZUxhbmd1YWdlKGxuZywgY2FsbGJhY2spIHtcbiAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gbG5nO1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0aGlzLmVtaXQoJ2xhbmd1YWdlQ2hhbmdpbmcnLCBsbmcpO1xuICAgIGNvbnN0IHNldExuZ1Byb3BzID0gbCA9PiB7XG4gICAgICB0aGlzLmxhbmd1YWdlID0gbDtcbiAgICAgIHRoaXMubGFuZ3VhZ2VzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsKTtcbiAgICAgIHRoaXMucmVzb2x2ZWRMYW5ndWFnZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc2V0UmVzb2x2ZWRMYW5ndWFnZShsKTtcbiAgICB9O1xuICAgIGNvbnN0IGRvbmUgPSAoZXJyLCBsKSA9PiB7XG4gICAgICBpZiAobCkge1xuICAgICAgICBpZiAodGhpcy5pc0xhbmd1YWdlQ2hhbmdpbmdUbyA9PT0gbG5nKSB7XG4gICAgICAgICAgc2V0TG5nUHJvcHMobCk7XG4gICAgICAgICAgdGhpcy50cmFuc2xhdG9yLmNoYW5nZUxhbmd1YWdlKGwpO1xuICAgICAgICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5lbWl0KCdsYW5ndWFnZUNoYW5nZWQnLCBsKTtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ2xhbmd1YWdlQ2hhbmdlZCcsIGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgoLi4uYXJncykgPT4gdGhpcy50KC4uLmFyZ3MpKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyLCAoLi4uYXJncykgPT4gdGhpcy50KC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldExuZyA9IGxuZ3MgPT4ge1xuICAgICAgaWYgKCFsbmcgJiYgIWxuZ3MgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yKSBsbmdzID0gW107XG4gICAgICBjb25zdCBmbCA9IGlzU3RyaW5nKGxuZ3MpID8gbG5ncyA6IGxuZ3MgJiYgbG5nc1swXTtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLnN0b3JlLmhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhmbCkgPyBmbCA6IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRCZXN0TWF0Y2hGcm9tQ29kZXMoaXNTdHJpbmcobG5ncykgPyBbbG5nc10gOiBsbmdzKTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIGlmICghdGhpcy5sYW5ndWFnZSkge1xuICAgICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50cmFuc2xhdG9yLmxhbmd1YWdlKSB0aGlzLnRyYW5zbGF0b3IuY2hhbmdlTGFuZ3VhZ2UobCk7XG4gICAgICAgIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvcj8uY2FjaGVVc2VyTGFuZ3VhZ2U/LihsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZFJlc291cmNlcyhsLCBlcnIgPT4ge1xuICAgICAgICBkb25lKGVyciwgbCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICghbG5nICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmFzeW5jKSB7XG4gICAgICBzZXRMbmcodGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdCgpKTtcbiAgICB9IGVsc2UgaWYgKCFsbmcgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5hc3luYykge1xuICAgICAgaWYgKHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QoKS50aGVuKHNldExuZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KHNldExuZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldExuZyhsbmcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgZ2V0Rml4ZWRUKGxuZywgbnMsIGtleVByZWZpeCkge1xuICAgIGNvbnN0IGZpeGVkVCA9IChrZXksIG9wdHMsIC4uLnJlc3QpID0+IHtcbiAgICAgIGxldCBvO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvID0gdGhpcy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKFtrZXksIG9wdHNdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvID0ge1xuICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG8ubG5nID0gby5sbmcgfHwgZml4ZWRULmxuZztcbiAgICAgIG8ubG5ncyA9IG8ubG5ncyB8fCBmaXhlZFQubG5ncztcbiAgICAgIG8ubnMgPSBvLm5zIHx8IGZpeGVkVC5ucztcbiAgICAgIGlmIChvLmtleVByZWZpeCAhPT0gJycpIG8ua2V5UHJlZml4ID0gby5rZXlQcmVmaXggfHwga2V5UHJlZml4IHx8IGZpeGVkVC5rZXlQcmVmaXg7XG4gICAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yIHx8ICcuJztcbiAgICAgIGxldCByZXN1bHRLZXk7XG4gICAgICBpZiAoby5rZXlQcmVmaXggJiYgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHJlc3VsdEtleSA9IGtleS5tYXAoayA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnZnVuY3Rpb24nKSBrID0ga2V5c0Zyb21TZWxlY3RvcihrLCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGAke28ua2V5UHJlZml4fSR7a2V5U2VwYXJhdG9yfSR7a31gO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSBrZXkgPSBrZXlzRnJvbVNlbGVjdG9yKGtleSwge1xuICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHRLZXkgPSBvLmtleVByZWZpeCA/IGAke28ua2V5UHJlZml4fSR7a2V5U2VwYXJhdG9yfSR7a2V5fWAgOiBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50KHJlc3VsdEtleSwgbyk7XG4gICAgfTtcbiAgICBpZiAoaXNTdHJpbmcobG5nKSkge1xuICAgICAgZml4ZWRULmxuZyA9IGxuZztcbiAgICB9IGVsc2Uge1xuICAgICAgZml4ZWRULmxuZ3MgPSBsbmc7XG4gICAgfVxuICAgIGZpeGVkVC5ucyA9IG5zO1xuICAgIGZpeGVkVC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgcmV0dXJuIGZpeGVkVDtcbiAgfVxuICB0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yPy50cmFuc2xhdGUoLi4uYXJncyk7XG4gIH1cbiAgZXhpc3RzKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yPy5leGlzdHMoLi4uYXJncyk7XG4gIH1cbiAgc2V0RGVmYXVsdE5hbWVzcGFjZShucykge1xuICAgIHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgPSBucztcbiAgfVxuICBoYXNMb2FkZWROYW1lc3BhY2UobnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdoYXNMb2FkZWROYW1lc3BhY2U6IGkxOG5leHQgd2FzIG5vdCBpbml0aWFsaXplZCcsIHRoaXMubGFuZ3VhZ2VzKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxhbmd1YWdlcyB8fCAhdGhpcy5sYW5ndWFnZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdoYXNMb2FkZWROYW1lc3BhY2U6IGkxOG4ubGFuZ3VhZ2VzIHdlcmUgdW5kZWZpbmVkIG9yIGVtcHR5JywgdGhpcy5sYW5ndWFnZXMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsbmcgPSBvcHRpb25zLmxuZyB8fCB0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgfHwgdGhpcy5sYW5ndWFnZXNbMF07XG4gICAgY29uc3QgZmFsbGJhY2tMbmcgPSB0aGlzLm9wdGlvbnMgPyB0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgOiBmYWxzZTtcbiAgICBjb25zdCBsYXN0TG5nID0gdGhpcy5sYW5ndWFnZXNbdGhpcy5sYW5ndWFnZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxuZy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJykgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgbG9hZE5vdFBlbmRpbmcgPSAobCwgbikgPT4ge1xuICAgICAgY29uc3QgbG9hZFN0YXRlID0gdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLnN0YXRlW2Ake2x9fCR7bn1gXTtcbiAgICAgIHJldHVybiBsb2FkU3RhdGUgPT09IC0xIHx8IGxvYWRTdGF0ZSA9PT0gMCB8fCBsb2FkU3RhdGUgPT09IDI7XG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5wcmVjaGVjaykge1xuICAgICAgY29uc3QgcHJlUmVzdWx0ID0gb3B0aW9ucy5wcmVjaGVjayh0aGlzLCBsb2FkTm90UGVuZGluZyk7XG4gICAgICBpZiAocHJlUmVzdWx0ICE9PSB1bmRlZmluZWQpIHJldHVybiBwcmVSZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5iYWNrZW5kIHx8IHRoaXMub3B0aW9ucy5yZXNvdXJjZXMgJiYgIXRoaXMub3B0aW9ucy5wYXJ0aWFsQnVuZGxlZExhbmd1YWdlcykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxvYWROb3RQZW5kaW5nKGxuZywgbnMpICYmICghZmFsbGJhY2tMbmcgfHwgbG9hZE5vdFBlbmRpbmcobGFzdExuZywgbnMpKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxvYWROYW1lc3BhY2VzKG5zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ucykge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcobnMpKSBucyA9IFtuc107XG4gICAgbnMuZm9yRWFjaChuID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihuKSA8IDApIHRoaXMub3B0aW9ucy5ucy5wdXNoKG4pO1xuICAgIH0pO1xuICAgIHRoaXMubG9hZFJlc291cmNlcyhlcnIgPT4ge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBsb2FkTGFuZ3VhZ2VzKGxuZ3MsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGlmIChpc1N0cmluZyhsbmdzKSkgbG5ncyA9IFtsbmdzXTtcbiAgICBjb25zdCBwcmVsb2FkZWQgPSB0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCBbXTtcbiAgICBjb25zdCBuZXdMbmdzID0gbG5ncy5maWx0ZXIobG5nID0+IHByZWxvYWRlZC5pbmRleE9mKGxuZykgPCAwICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5pc1N1cHBvcnRlZENvZGUobG5nKSk7XG4gICAgaWYgKCFuZXdMbmdzLmxlbmd0aCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMucHJlbG9hZCA9IHByZWxvYWRlZC5jb25jYXQobmV3TG5ncyk7XG4gICAgdGhpcy5sb2FkUmVzb3VyY2VzKGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGRpcihsbmcpIHtcbiAgICBpZiAoIWxuZykgbG5nID0gdGhpcy5yZXNvbHZlZExhbmd1YWdlIHx8ICh0aGlzLmxhbmd1YWdlcz8ubGVuZ3RoID4gMCA/IHRoaXMubGFuZ3VhZ2VzWzBdIDogdGhpcy5sYW5ndWFnZSk7XG4gICAgaWYgKCFsbmcpIHJldHVybiAncnRsJztcbiAgICB0cnkge1xuICAgICAgY29uc3QgbCA9IG5ldyBJbnRsLkxvY2FsZShsbmcpO1xuICAgICAgaWYgKGwgJiYgbC5nZXRUZXh0SW5mbykge1xuICAgICAgICBjb25zdCB0aSA9IGwuZ2V0VGV4dEluZm8oKTtcbiAgICAgICAgaWYgKHRpICYmIHRpLmRpcmVjdGlvbikgcmV0dXJuIHRpLmRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGNvbnN0IHJ0bExuZ3MgPSBbJ2FyJywgJ3NodScsICdzcXInLCAnc3NoJywgJ3hhYScsICd5aGQnLCAneXVkJywgJ2FhbycsICdhYmgnLCAnYWJ2JywgJ2FjbScsICdhY3EnLCAnYWN3JywgJ2FjeCcsICdhY3knLCAnYWRmJywgJ2FkcycsICdhZWInLCAnYWVjJywgJ2FmYicsICdhanAnLCAnYXBjJywgJ2FwZCcsICdhcmInLCAnYXJxJywgJ2FycycsICdhcnknLCAnYXJ6JywgJ2F1eicsICdhdmwnLCAnYXloJywgJ2F5bCcsICdheW4nLCAnYXlwJywgJ2JieicsICdwZ2EnLCAnaGUnLCAnaXcnLCAncHMnLCAncGJ0JywgJ3BidScsICdwc3QnLCAncHJwJywgJ3ByZCcsICd1ZycsICd1cicsICd5ZGQnLCAneWRzJywgJ3lpaCcsICdqaScsICd5aScsICdoYm8nLCAnbWVuJywgJ3htbicsICdmYScsICdqcHInLCAncGVvJywgJ3BlcycsICdwcnMnLCAnZHYnLCAnc2FtJywgJ2NrYiddO1xuICAgIGNvbnN0IGxhbmd1YWdlVXRpbHMgPSB0aGlzLnNlcnZpY2VzPy5sYW5ndWFnZVV0aWxzIHx8IG5ldyBMYW5ndWFnZVV0aWwoZ2V0KCkpO1xuICAgIGlmIChsbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCctbGF0bicpID4gMSkgcmV0dXJuICdsdHInO1xuICAgIHJldHVybiBydGxMbmdzLmluZGV4T2YobGFuZ3VhZ2VVdGlscy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShsbmcpKSA+IC0xIHx8IGxuZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJy1hcmFiJykgPiAxID8gJ3J0bCcgOiAnbHRyJztcbiAgfVxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2Uob3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgSTE4bihvcHRpb25zLCBjYWxsYmFjayk7XG4gIH1cbiAgY2xvbmVJbnN0YW5jZShvcHRpb25zID0ge30sIGNhbGxiYWNrID0gbm9vcCkge1xuICAgIGNvbnN0IGZvcmtSZXNvdXJjZVN0b3JlID0gb3B0aW9ucy5mb3JrUmVzb3VyY2VTdG9yZTtcbiAgICBpZiAoZm9ya1Jlc291cmNlU3RvcmUpIGRlbGV0ZSBvcHRpb25zLmZvcmtSZXNvdXJjZVN0b3JlO1xuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLi4ue1xuICAgICAgICBpc0Nsb25lOiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBJMThuKG1lcmdlZE9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmRlYnVnICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5wcmVmaXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xvbmUubG9nZ2VyID0gY2xvbmUubG9nZ2VyLmNsb25lKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBtZW1iZXJzVG9Db3B5ID0gWydzdG9yZScsICdzZXJ2aWNlcycsICdsYW5ndWFnZSddO1xuICAgIG1lbWJlcnNUb0NvcHkuZm9yRWFjaChtID0+IHtcbiAgICAgIGNsb25lW21dID0gdGhpc1ttXTtcbiAgICB9KTtcbiAgICBjbG9uZS5zZXJ2aWNlcyA9IHtcbiAgICAgIC4uLnRoaXMuc2VydmljZXNcbiAgICB9O1xuICAgIGNsb25lLnNlcnZpY2VzLnV0aWxzID0ge1xuICAgICAgaGFzTG9hZGVkTmFtZXNwYWNlOiBjbG9uZS5oYXNMb2FkZWROYW1lc3BhY2UuYmluZChjbG9uZSlcbiAgICB9O1xuICAgIGlmIChmb3JrUmVzb3VyY2VTdG9yZSkge1xuICAgICAgY29uc3QgY2xvbmVkRGF0YSA9IE9iamVjdC5rZXlzKHRoaXMuc3RvcmUuZGF0YSkucmVkdWNlKChwcmV2LCBsKSA9PiB7XG4gICAgICAgIHByZXZbbF0gPSB7XG4gICAgICAgICAgLi4udGhpcy5zdG9yZS5kYXRhW2xdXG4gICAgICAgIH07XG4gICAgICAgIHByZXZbbF0gPSBPYmplY3Qua2V5cyhwcmV2W2xdKS5yZWR1Y2UoKGFjYywgbikgPT4ge1xuICAgICAgICAgIGFjY1tuXSA9IHtcbiAgICAgICAgICAgIC4uLnByZXZbbF1bbl1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHByZXZbbF0pO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0sIHt9KTtcbiAgICAgIGNsb25lLnN0b3JlID0gbmV3IFJlc291cmNlU3RvcmUoY2xvbmVkRGF0YSwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICBjbG9uZS5zZXJ2aWNlcy5yZXNvdXJjZVN0b3JlID0gY2xvbmUuc3RvcmU7XG4gICAgfVxuICAgIGNsb25lLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihjbG9uZS5zZXJ2aWNlcywgbWVyZ2VkT3B0aW9ucyk7XG4gICAgY2xvbmUudHJhbnNsYXRvci5vbignKicsIChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgY2xvbmUuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfSk7XG4gICAgY2xvbmUuaW5pdChtZXJnZWRPcHRpb25zLCBjYWxsYmFjayk7XG4gICAgY2xvbmUudHJhbnNsYXRvci5vcHRpb25zID0gbWVyZ2VkT3B0aW9ucztcbiAgICBjbG9uZS50cmFuc2xhdG9yLmJhY2tlbmRDb25uZWN0b3Iuc2VydmljZXMudXRpbHMgPSB7XG4gICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IGNsb25lLmhhc0xvYWRlZE5hbWVzcGFjZS5iaW5kKGNsb25lKVxuICAgIH07XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgIGxhbmd1YWdlczogdGhpcy5sYW5ndWFnZXMsXG4gICAgICByZXNvbHZlZExhbmd1YWdlOiB0aGlzLnJlc29sdmVkTGFuZ3VhZ2VcbiAgICB9O1xuICB9XG59XG5jb25zdCBpbnN0YW5jZSA9IEkxOG4uY3JlYXRlSW5zdGFuY2UoKTtcbmluc3RhbmNlLmNyZWF0ZUluc3RhbmNlID0gSTE4bi5jcmVhdGVJbnN0YW5jZTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2UgPSBpbnN0YW5jZS5jcmVhdGVJbnN0YW5jZTtcbmNvbnN0IGRpciA9IGluc3RhbmNlLmRpcjtcbmNvbnN0IGluaXQgPSBpbnN0YW5jZS5pbml0O1xuY29uc3QgbG9hZFJlc291cmNlcyA9IGluc3RhbmNlLmxvYWRSZXNvdXJjZXM7XG5jb25zdCByZWxvYWRSZXNvdXJjZXMgPSBpbnN0YW5jZS5yZWxvYWRSZXNvdXJjZXM7XG5jb25zdCB1c2UgPSBpbnN0YW5jZS51c2U7XG5jb25zdCBjaGFuZ2VMYW5ndWFnZSA9IGluc3RhbmNlLmNoYW5nZUxhbmd1YWdlO1xuY29uc3QgZ2V0Rml4ZWRUID0gaW5zdGFuY2UuZ2V0Rml4ZWRUO1xuY29uc3QgdCA9IGluc3RhbmNlLnQ7XG5jb25zdCBleGlzdHMgPSBpbnN0YW5jZS5leGlzdHM7XG5jb25zdCBzZXREZWZhdWx0TmFtZXNwYWNlID0gaW5zdGFuY2Uuc2V0RGVmYXVsdE5hbWVzcGFjZTtcbmNvbnN0IGhhc0xvYWRlZE5hbWVzcGFjZSA9IGluc3RhbmNlLmhhc0xvYWRlZE5hbWVzcGFjZTtcbmNvbnN0IGxvYWROYW1lc3BhY2VzID0gaW5zdGFuY2UubG9hZE5hbWVzcGFjZXM7XG5jb25zdCBsb2FkTGFuZ3VhZ2VzID0gaW5zdGFuY2UubG9hZExhbmd1YWdlcztcblxuZXhwb3J0IHsgY2hhbmdlTGFuZ3VhZ2UsIGNyZWF0ZUluc3RhbmNlLCBpbnN0YW5jZSBhcyBkZWZhdWx0LCBkaXIsIGV4aXN0cywgZ2V0Rml4ZWRULCBoYXNMb2FkZWROYW1lc3BhY2UsIGluaXQsIGtleXNGcm9tU2VsZWN0b3IgYXMga2V5RnJvbVNlbGVjdG9yLCBsb2FkTGFuZ3VhZ2VzLCBsb2FkTmFtZXNwYWNlcywgbG9hZFJlc291cmNlcywgcmVsb2FkUmVzb3VyY2VzLCBzZXREZWZhdWx0TmFtZXNwYWNlLCB0LCB1c2UgfTtcbiJdLCJuYW1lcyI6WyJpc1N0cmluZyIsIm9iaiIsImRlZmVyIiwicmVzIiwicmVqIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibWFrZVN0cmluZyIsIm9iamVjdCIsImNvcHkiLCJhIiwicyIsInQiLCJmb3JFYWNoIiwibSIsImxhc3RPZlBhdGhTZXBhcmF0b3JSZWdFeHAiLCJjbGVhbktleSIsImtleSIsImluZGV4T2YiLCJyZXBsYWNlIiwiY2FuTm90VHJhdmVyc2VEZWVwZXIiLCJnZXRMYXN0T2ZQYXRoIiwicGF0aCIsIkVtcHR5Iiwic3RhY2siLCJzcGxpdCIsInN0YWNrSW5kZXgiLCJsZW5ndGgiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJrIiwic2V0UGF0aCIsIm5ld1ZhbHVlIiwidW5kZWZpbmVkIiwiZSIsInAiLCJzbGljZSIsImxhc3QiLCJwdXNoUGF0aCIsImNvbmNhdCIsInB1c2giLCJnZXRQYXRoIiwiZ2V0UGF0aFdpdGhEZWZhdWx0cyIsImRhdGEiLCJkZWZhdWx0RGF0YSIsInZhbHVlIiwiZGVlcEV4dGVuZCIsInRhcmdldCIsInNvdXJjZSIsIm92ZXJ3cml0ZSIsInByb3AiLCJTdHJpbmciLCJyZWdleEVzY2FwZSIsInN0ciIsIl9lbnRpdHlNYXAiLCJlc2NhcGUiLCJSZWdFeHBDYWNoZSIsImNvbnN0cnVjdG9yIiwiY2FwYWNpdHkiLCJyZWdFeHBNYXAiLCJNYXAiLCJyZWdFeHBRdWV1ZSIsImdldFJlZ0V4cCIsInBhdHRlcm4iLCJyZWdFeHBGcm9tQ2FjaGUiLCJnZXQiLCJyZWdFeHBOZXciLCJSZWdFeHAiLCJkZWxldGUiLCJzaGlmdCIsInNldCIsImNoYXJzIiwibG9va3NMaWtlT2JqZWN0UGF0aFJlZ0V4cENhY2hlIiwibG9va3NMaWtlT2JqZWN0UGF0aCIsIm5zU2VwYXJhdG9yIiwia2V5U2VwYXJhdG9yIiwicG9zc2libGVDaGFycyIsImZpbHRlciIsImMiLCJyIiwibWFwIiwiam9pbiIsIm1hdGNoZWQiLCJ0ZXN0Iiwia2kiLCJzdWJzdHJpbmciLCJkZWVwRmluZCIsInRva2VucyIsImN1cnJlbnQiLCJpIiwibmV4dCIsIm5leHRQYXRoIiwiaiIsImdldENsZWFuZWRDb2RlIiwiY29kZSIsImNvbnNvbGVMb2dnZXIiLCJ0eXBlIiwibG9nIiwiYXJncyIsIm91dHB1dCIsIndhcm4iLCJlcnJvciIsImNvbnNvbGUiLCJhcHBseSIsIkxvZ2dlciIsImNvbmNyZXRlTG9nZ2VyIiwib3B0aW9ucyIsImluaXQiLCJwcmVmaXgiLCJsb2dnZXIiLCJkZWJ1ZyIsImZvcndhcmQiLCJkZXByZWNhdGUiLCJsdmwiLCJkZWJ1Z09ubHkiLCJjcmVhdGUiLCJtb2R1bGVOYW1lIiwiY2xvbmUiLCJiYXNlTG9nZ2VyIiwiRXZlbnRFbWl0dGVyIiwib2JzZXJ2ZXJzIiwib24iLCJldmVudHMiLCJsaXN0ZW5lciIsImV2ZW50IiwibnVtTGlzdGVuZXJzIiwib2ZmIiwiZW1pdCIsImNsb25lZCIsIkFycmF5IiwiZnJvbSIsImVudHJpZXMiLCJvYnNlcnZlciIsIm51bVRpbWVzQWRkZWQiLCJSZXNvdXJjZVN0b3JlIiwibnMiLCJkZWZhdWx0TlMiLCJpZ25vcmVKU09OU3RydWN0dXJlIiwiYWRkTmFtZXNwYWNlcyIsInJlbW92ZU5hbWVzcGFjZXMiLCJpbmRleCIsInNwbGljZSIsImdldFJlc291cmNlIiwibG5nIiwiaXNBcnJheSIsInJlc3VsdCIsImFkZFJlc291cmNlIiwic2lsZW50IiwiYWRkUmVzb3VyY2VzIiwicmVzb3VyY2VzIiwiYWRkUmVzb3VyY2VCdW5kbGUiLCJkZWVwIiwic2tpcENvcHkiLCJwYWNrIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicmVtb3ZlUmVzb3VyY2VCdW5kbGUiLCJoYXNSZXNvdXJjZUJ1bmRsZSIsImdldFJlc291cmNlQnVuZGxlIiwiZ2V0RGF0YUJ5TGFuZ3VhZ2UiLCJoYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMiLCJuIiwia2V5cyIsImZpbmQiLCJ2IiwidG9KU09OIiwicG9zdFByb2Nlc3NvciIsInByb2Nlc3NvcnMiLCJhZGRQb3N0UHJvY2Vzc29yIiwibW9kdWxlIiwibmFtZSIsImhhbmRsZSIsInRyYW5zbGF0b3IiLCJwcm9jZXNzb3IiLCJwcm9jZXNzIiwiUEFUSF9LRVkiLCJTeW1ib2wiLCJjcmVhdGVQcm94eSIsInN0YXRlIiwiaGFuZGxlciIsInByb3h5IiwicmV2b2tlIiwiUHJveHkiLCJyZXZvY2FibGUiLCJrZXlzRnJvbVNlbGVjdG9yIiwic2VsZWN0b3IiLCJvcHRzIiwiY2hlY2tlZExvYWRlZEZvciIsInNob3VsZEhhbmRsZUFzT2JqZWN0IiwiVHJhbnNsYXRvciIsInNlcnZpY2VzIiwiY2hhbmdlTGFuZ3VhZ2UiLCJsYW5ndWFnZSIsImV4aXN0cyIsIm8iLCJpbnRlcnBvbGF0aW9uIiwib3B0IiwicmVzb2x2ZWQiLCJpc09iamVjdCIsInJldHVybk9iamVjdHMiLCJleHRyYWN0RnJvbUtleSIsIm5hbWVzcGFjZXMiLCJ3b3VsZENoZWNrRm9yTnNJbktleSIsInNlZW1zTmF0dXJhbExhbmd1YWdlIiwidXNlckRlZmluZWRLZXlTZXBhcmF0b3IiLCJ1c2VyRGVmaW5lZE5zU2VwYXJhdG9yIiwibWF0Y2giLCJpbnRlcnBvbGF0b3IiLCJuZXN0aW5nUmVnZXhwIiwicGFydHMiLCJ0cmFuc2xhdGUiLCJsYXN0S2V5Iiwib3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIiLCJhcmd1bWVudHMiLCJyZXR1cm5EZXRhaWxzIiwibmFtZXNwYWNlIiwiYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUiLCJ0b0xvd2VyQ2FzZSIsInVzZWRLZXkiLCJleGFjdFVzZWRLZXkiLCJ1c2VkTG5nIiwidXNlZE5TIiwidXNlZFBhcmFtcyIsImdldFVzZWRQYXJhbXNEZXRhaWxzIiwicmVzVXNlZEtleSIsInJlc0V4YWN0VXNlZEtleSIsIm5vT2JqZWN0Iiwiam9pbkFycmF5cyIsImhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0IiwiaTE4bkZvcm1hdCIsImhhbmRsZUFzT2JqZWN0IiwibmVlZHNQbHVyYWxIYW5kbGluZyIsImNvdW50IiwiaGFzRGVmYXVsdFZhbHVlIiwiZGVmYXVsdFZhbHVlU3VmZml4IiwicGx1cmFsUmVzb2x2ZXIiLCJnZXRTdWZmaXgiLCJkZWZhdWx0VmFsdWVTdWZmaXhPcmRpbmFsRmFsbGJhY2siLCJvcmRpbmFsIiwibmVlZHNaZXJvU3VmZml4TG9va3VwIiwiZGVmYXVsdFZhbHVlIiwicGx1cmFsU2VwYXJhdG9yIiwicmVzRm9yT2JqSG5kbCIsInJlc1R5cGUiLCJ0b1N0cmluZyIsInJldHVybmVkT2JqZWN0SGFuZGxlciIsInJlc1R5cGVJc0FycmF5IiwibmV3S2V5VG9Vc2UiLCJkZWVwS2V5IiwiZXh0ZW5kVHJhbnNsYXRpb24iLCJ1c2VkRGVmYXVsdCIsImlzVmFsaWRMb29rdXAiLCJtaXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkiLCJyZXNGb3JNaXNzaW5nIiwidXBkYXRlTWlzc2luZyIsImZrIiwibG5ncyIsImZhbGxiYWNrTG5ncyIsImxhbmd1YWdlVXRpbHMiLCJnZXRGYWxsYmFja0NvZGVzIiwiZmFsbGJhY2tMbmciLCJzYXZlTWlzc2luZ1RvIiwidG9SZXNvbHZlSGllcmFyY2h5Iiwic2VuZCIsImwiLCJzcGVjaWZpY0RlZmF1bHRWYWx1ZSIsImRlZmF1bHRGb3JNaXNzaW5nIiwibWlzc2luZ0tleUhhbmRsZXIiLCJiYWNrZW5kQ29ubmVjdG9yIiwic2F2ZU1pc3NpbmciLCJzYXZlTWlzc2luZ1BsdXJhbHMiLCJzdWZmaXhlcyIsImdldFN1ZmZpeGVzIiwic3VmZml4IiwiYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5IiwicGFyc2VNaXNzaW5nS2V5SGFuZGxlciIsImRlZmF1bHRWYXJpYWJsZXMiLCJza2lwSW50ZXJwb2xhdGlvbiIsInNraXBPblZhcmlhYmxlcyIsIm5lc3RCZWYiLCJuYiIsImludGVycG9sYXRlIiwibmEiLCJuZXN0QWZ0IiwibmVzdCIsImNvbnRleHQiLCJyZXNldCIsInBvc3RQcm9jZXNzIiwicG9zdFByb2Nlc3Nvck5hbWVzIiwiYXBwbHlQb3N0UHJvY2Vzc29yIiwicG9zdFByb2Nlc3NQYXNzUmVzb2x2ZWQiLCJpMThuUmVzb2x2ZWQiLCJmb3VuZCIsImV4dHJhY3RlZCIsImZhbGxiYWNrTlMiLCJuZWVkc0NvbnRleHRIYW5kbGluZyIsImNvZGVzIiwidXRpbHMiLCJoYXNMb2FkZWROYW1lc3BhY2UiLCJmaW5hbEtleXMiLCJhZGRMb29rdXBLZXlzIiwicGx1cmFsU3VmZml4IiwiemVyb1N1ZmZpeCIsIm9yZGluYWxQcmVmaXgiLCJjb250ZXh0S2V5IiwiY29udGV4dFNlcGFyYXRvciIsInBvc3NpYmxlS2V5IiwicG9wIiwicmV0dXJuTnVsbCIsInJldHVybkVtcHR5U3RyaW5nIiwicmVzb3VyY2VTdG9yZSIsIm9wdGlvbnNLZXlzIiwidXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhIiwib3B0aW9uIiwiTGFuZ3VhZ2VVdGlsIiwic3VwcG9ydGVkTG5ncyIsImdldFNjcmlwdFBhcnRGcm9tQ29kZSIsImZvcm1hdExhbmd1YWdlQ29kZSIsImdldExhbmd1YWdlUGFydEZyb21Db2RlIiwiZm9ybWF0dGVkQ29kZSIsIkludGwiLCJnZXRDYW5vbmljYWxMb2NhbGVzIiwibG93ZXJDYXNlTG5nIiwiY2xlYW5Db2RlIiwiaXNTdXBwb3J0ZWRDb2RlIiwibG9hZCIsIm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncyIsImdldEJlc3RNYXRjaEZyb21Db2RlcyIsImNsZWFuZWRMbmciLCJsbmdTY09ubHkiLCJsbmdPbmx5Iiwic3VwcG9ydGVkTG5nIiwiZmFsbGJhY2tzIiwiZGVmYXVsdCIsImZhbGxiYWNrQ29kZSIsImZhbGxiYWNrQ29kZXMiLCJhZGRDb2RlIiwiZmMiLCJzdWZmaXhlc09yZGVyIiwiemVybyIsIm9uZSIsInR3byIsImZldyIsIm1hbnkiLCJvdGhlciIsImR1bW15UnVsZSIsInNlbGVjdCIsInJlc29sdmVkT3B0aW9ucyIsInBsdXJhbENhdGVnb3JpZXMiLCJQbHVyYWxSZXNvbHZlciIsInBsdXJhbFJ1bGVzQ2FjaGUiLCJhZGRSdWxlIiwicnVsZXMiLCJjbGVhckNhY2hlIiwiZ2V0UnVsZSIsImNsZWFuZWRDb2RlIiwiY2FjaGVLZXkiLCJydWxlIiwiUGx1cmFsUnVsZXMiLCJlcnIiLCJsbmdQYXJ0IiwibmVlZHNQbHVyYWwiLCJnZXRQbHVyYWxGb3Jtc09mS2V5Iiwic29ydCIsInBsdXJhbENhdGVnb3J5MSIsInBsdXJhbENhdGVnb3J5MiIsInBsdXJhbENhdGVnb3J5IiwicHJlcGVuZCIsImRlZXBGaW5kV2l0aERlZmF1bHRzIiwicmVnZXhTYWZlIiwidmFsIiwiSW50ZXJwb2xhdG9yIiwiZm9ybWF0IiwiZXNjYXBlVmFsdWUiLCJlc2NhcGUkMSIsInVzZVJhd1ZhbHVlVG9Fc2NhcGUiLCJwcmVmaXhFc2NhcGVkIiwic3VmZml4RXNjYXBlZCIsImZvcm1hdFNlcGFyYXRvciIsInVuZXNjYXBlU3VmZml4IiwidW5lc2NhcGVQcmVmaXgiLCJuZXN0aW5nUHJlZml4IiwibmVzdGluZ1ByZWZpeEVzY2FwZWQiLCJuZXN0aW5nU3VmZml4IiwibmVzdGluZ1N1ZmZpeEVzY2FwZWQiLCJuZXN0aW5nT3B0aW9uc1NlcGFyYXRvciIsIm1heFJlcGxhY2VzIiwiYWx3YXlzRm9ybWF0IiwicmVzZXRSZWdFeHAiLCJnZXRPclJlc2V0UmVnRXhwIiwiZXhpc3RpbmdSZWdFeHAiLCJsYXN0SW5kZXgiLCJyZWdleHAiLCJyZWdleHBVbmVzY2FwZSIsInJlcGxhY2VzIiwiaGFuZGxlRm9ybWF0IiwiaW50ZXJwb2xhdGlvbmtleSIsInRyaW0iLCJmIiwibWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyIiwidG9kb3MiLCJyZWdleCIsInNhZmVWYWx1ZSIsInRvZG8iLCJleGVjIiwibWF0Y2hlZFZhciIsInRlbXAiLCJjbG9uZWRPcHRpb25zIiwiaGFuZGxlSGFzT3B0aW9ucyIsImluaGVyaXRlZE9wdGlvbnMiLCJzZXAiLCJvcHRpb25zU3RyaW5nIiwibWF0Y2hlZFNpbmdsZVF1b3RlcyIsIm1hdGNoZWREb3VibGVRdW90ZXMiLCJmb3JtYXR0ZXJzIiwia2V5RW5kSW5kZXgiLCJsYXN0SW5kZXhPZiIsImVsZW0iLCJCb29sZWFuIiwicmVkdWNlIiwicGFyc2VGb3JtYXRTdHIiLCJmb3JtYXRTdHIiLCJmb3JtYXROYW1lIiwiZm9ybWF0T3B0aW9ucyIsIm9wdFN0ciIsImN1cnJlbmN5IiwicmFuZ2UiLCJyZXN0IiwidHJpbW1lZEtleSIsImlzTmFOIiwicGFyc2VJbnQiLCJjcmVhdGVDYWNoZWRGb3JtYXR0ZXIiLCJmbiIsImNhY2hlIiwib3B0Rm9yQ2FjaGUiLCJmb3JtYXRQYXJhbXMiLCJmcm0iLCJjcmVhdGVOb25DYWNoZWRGb3JtYXR0ZXIiLCJGb3JtYXR0ZXIiLCJjZiIsImNhY2hlSW5CdWlsdEZvcm1hdHMiLCJmb3JtYXRzIiwibnVtYmVyIiwiZm9ybWF0dGVyIiwiTnVtYmVyRm9ybWF0Iiwic3R5bGUiLCJkYXRldGltZSIsIkRhdGVUaW1lRm9ybWF0IiwicmVsYXRpdmV0aW1lIiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwibGlzdCIsIkxpc3RGb3JtYXQiLCJhZGQiLCJhZGRDYWNoZWQiLCJmaW5kSW5kZXgiLCJtZW0iLCJmb3JtYXR0ZWQiLCJ2YWxPcHRpb25zIiwibG9jYWxlIiwicmVtb3ZlUGVuZGluZyIsInEiLCJwZW5kaW5nIiwicGVuZGluZ0NvdW50IiwiQ29ubmVjdG9yIiwiYmFja2VuZCIsInN0b3JlIiwid2FpdGluZ1JlYWRzIiwibWF4UGFyYWxsZWxSZWFkcyIsInJlYWRpbmdDYWxscyIsIm1heFJldHJpZXMiLCJyZXRyeVRpbWVvdXQiLCJxdWV1ZSIsInF1ZXVlTG9hZCIsImxhbmd1YWdlcyIsImNhbGxiYWNrIiwidG9Mb2FkIiwidG9Mb2FkTGFuZ3VhZ2VzIiwidG9Mb2FkTmFtZXNwYWNlcyIsImhhc0FsbE5hbWVzcGFjZXMiLCJyZWxvYWQiLCJsb2FkZWQiLCJlcnJvcnMiLCJkb25lIiwibG9hZGVkS2V5cyIsInJlYWQiLCJmY05hbWUiLCJ0cmllZCIsIndhaXQiLCJyZXNvbHZlciIsInNldFRpbWVvdXQiLCJiaW5kIiwidGhlbiIsImNhdGNoIiwicHJlcGFyZUxvYWRpbmciLCJsb2FkT25lIiwiZmFsbGJhY2tWYWx1ZSIsImlzVXBkYXRlIiwiY2xiIiwiaW5pdEFzeW5jIiwicHJlbG9hZCIsInNpbXBsaWZ5UGx1cmFsU3VmZml4IiwicGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMiLCJyZXQiLCJ0RGVzY3JpcHRpb24iLCJ0cmFuc2Zvcm1PcHRpb25zIiwiaW5pdEltbWVkaWF0ZSIsIm5vb3AiLCJiaW5kTWVtYmVyRnVuY3Rpb25zIiwiaW5zdCIsIm1lbXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0UHJvdG90eXBlT2YiLCJJMThuIiwibW9kdWxlcyIsImV4dGVybmFsIiwiaXNJbml0aWFsaXplZCIsImlzQ2xvbmUiLCJpc0luaXRpYWxpemluZyIsImRlZk9wdHMiLCJjcmVhdGVDbGFzc09uRGVtYW5kIiwiQ2xhc3NPck9iamVjdCIsImx1IiwidXNpbmdMZWdhY3lGb3JtYXRGdW5jdGlvbiIsImxhbmd1YWdlRGV0ZWN0b3IiLCJkZXRlY3Rpb24iLCJzdG9yZUFwaSIsInN0b3JlQXBpQ2hhaW5lZCIsImRlZmVycmVkIiwiZmluaXNoIiwiaW5pdGlhbGl6ZWRTdG9yZU9uY2UiLCJsb2FkUmVzb3VyY2VzIiwidXNlZENhbGxiYWNrIiwiYXBwZW5kIiwicmVzb2x2ZWRMYW5ndWFnZSIsInNldFJlc29sdmVkTGFuZ3VhZ2UiLCJyZWxvYWRSZXNvdXJjZXMiLCJ1c2UiLCJFcnJvciIsImxpIiwibG5nSW5MbmdzIiwidW5zaGlmdCIsImlzTGFuZ3VhZ2VDaGFuZ2luZ1RvIiwic2V0TG5nUHJvcHMiLCJzZXRMbmciLCJmbCIsImNhY2hlVXNlckxhbmd1YWdlIiwiYXN5bmMiLCJkZXRlY3QiLCJnZXRGaXhlZFQiLCJrZXlQcmVmaXgiLCJmaXhlZFQiLCJyZXN1bHRLZXkiLCJzZXREZWZhdWx0TmFtZXNwYWNlIiwibGFzdExuZyIsImxvYWROb3RQZW5kaW5nIiwibG9hZFN0YXRlIiwicHJlY2hlY2siLCJwcmVSZXN1bHQiLCJsb2FkTmFtZXNwYWNlcyIsImxvYWRMYW5ndWFnZXMiLCJwcmVsb2FkZWQiLCJuZXdMbmdzIiwiZGlyIiwiTG9jYWxlIiwiZ2V0VGV4dEluZm8iLCJ0aSIsImRpcmVjdGlvbiIsInJ0bExuZ3MiLCJjcmVhdGVJbnN0YW5jZSIsImNsb25lSW5zdGFuY2UiLCJmb3JrUmVzb3VyY2VTdG9yZSIsIm1lcmdlZE9wdGlvbnMiLCJtZW1iZXJzVG9Db3B5IiwiY2xvbmVkRGF0YSIsInByZXYiLCJhY2MiLCJpbnN0YW5jZSIsImtleUZyb21TZWxlY3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/i18next/dist/esm/i18next.js\n");

/***/ })

};
;